<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>Multidimensional image processing (scipy.ndimage) &mdash; SciPy v1.1.0.dev0+04759f9 Reference Guide</title>
    
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-extend.css">
    <link rel="stylesheet" href="../_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.1.0.dev0+04759f9',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/scipy-mathjax/MathJax.js?config=scipy-mathjax"></script>
    <script type="text/javascript" src="../_static/js/copybutton.js"></script>
    <link rel="index" title="Index" href="../genindex.html" >
    <link rel="search" title="Search" href="../search.html" >
    <link rel="top" title="SciPy v1.1.0.dev0+04759f9 Reference Guide" href="../index.html" >
    <link rel="up" title="SciPy Tutorial" href="index.html" >
    <link rel="next" title="File IO (scipy.io)" href="io.html" >
    <link rel="prev" title="Wrapped Cauchy Distribution" href="stats/continuous_wrapcauchy.html" > 
  </head>
  <body>

  <div class="container">
    <div class="header">
    </div>
  </div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
	
        <li class="active"><a href="../index.html">SciPy v1.1.0.dev0+04759f9 Reference Guide</a></li>
	
          <li class="active"><a href="index.html" accesskey="U">SciPy Tutorial</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="../py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
      <li class="active">
        <a href="io.html" title="File IO (scipy.io)"
           accesskey="N">next</a>
      </li>
      <li class="active">
        <a href="stats/continuous_wrapcauchy.html" title="Wrapped Cauchy Distribution"
           accesskey="P">previous</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/scipyshiny_small.png" alt="Logo">
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Multidimensional image processing (<code class="docutils literal"><span class="pre">scipy.ndimage</span></code>)</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#properties-shared-by-all-functions">Properties shared by all functions</a></li>
<li><a class="reference internal" href="#filter-functions">Filter functions</a><ul>
<li><a class="reference internal" href="#correlation-and-convolution">Correlation and convolution</a></li>
<li><a class="reference internal" href="#smoothing-filters">Smoothing filters</a></li>
<li><a class="reference internal" href="#filters-based-on-order-statistics">Filters based on order statistics</a></li>
<li><a class="reference internal" href="#derivatives">Derivatives</a></li>
<li><a class="reference internal" href="#generic-filter-functions">Generic filter functions</a></li>
<li><a class="reference internal" href="#fourier-domain-filters">Fourier domain filters</a></li>
</ul>
</li>
<li><a class="reference internal" href="#interpolation-functions">Interpolation functions</a><ul>
<li><a class="reference internal" href="#spline-pre-filters">Spline pre-filters</a></li>
<li><a class="reference internal" href="#id2">Interpolation functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#morphology">Morphology</a><ul>
<li><a class="reference internal" href="#binary-morphology">Binary morphology</a></li>
<li><a class="reference internal" href="#grey-scale-morphology">Grey-scale morphology</a></li>
</ul>
</li>
<li><a class="reference internal" href="#distance-transforms">Distance transforms</a></li>
<li><a class="reference internal" href="#segmentation-and-labeling">Segmentation and labeling</a></li>
<li><a class="reference internal" href="#object-measurements">Object measurements</a></li>
<li><a class="reference internal" href="#extending-scipy-ndimage-in-c">Extending <code class="docutils literal"><span class="pre">scipy.ndimage</span></code> in C</a></li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="stats/continuous_wrapcauchy.html"
                        title="previous chapter">Wrapped Cauchy Distribution</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="io.html"
                        title="next chapter">File IO (<code class="docutils literal"><span class="pre">scipy.io</span></code>)</a></p>


        </div>
      </div>
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="multidimensional-image-processing-scipy-ndimage">
<h1>Multidimensional image processing (<a class="reference internal" href="../ndimage.html#module-scipy.ndimage" title="scipy.ndimage"><code class="xref py py-obj docutils literal"><span class="pre">scipy.ndimage</span></code></a>)<a class="headerlink" href="#multidimensional-image-processing-scipy-ndimage" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<span id="ndimage-introduction"></span><h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Image processing and analysis are generally seen as operations on
two-dimensional arrays of values. There are however a number of
fields where images of higher dimensionality must be analyzed. Good
examples of these are medical imaging and biological imaging.
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/index.html#module-numpy" title="(in NumPy v1.13)"><code class="xref py py-mod docutils literal"><span class="pre">numpy</span></code></a> is suited very well for this type of applications due
its inherent multidimensional nature. The <a class="reference internal" href="../ndimage.html#module-scipy.ndimage" title="scipy.ndimage"><code class="xref py py-mod docutils literal"><span class="pre">scipy.ndimage</span></code></a>
packages provides a number of general image processing and analysis
functions that are designed to operate with arrays of arbitrary
dimensionality. The packages currently includes functions for
linear and non-linear filtering, binary morphology, B-spline
interpolation, and object measurements.</p>
</div>
<div class="section" id="properties-shared-by-all-functions">
<span id="ndimage-properties-shared-by-all-functions"></span><h2>Properties shared by all functions<a class="headerlink" href="#properties-shared-by-all-functions" title="Permalink to this headline">¶</a></h2>
<p>All functions share some common properties. Notably, all functions
allow the specification of an output array with the <em>output</em>
argument. With this argument you can specify an array that will be
changed in-place with the result with the operation. In this case
the result is not returned. Usually, using the <em>output</em> argument is
more efficient, since an existing array is used to store the
result.</p>
<p>The type of arrays returned is dependent on the type of operation,
but it is in most cases equal to the type of the input. If,
however, the <em>output</em> argument is used, the type of the result is
equal to the type of the specified output argument. If no output
argument is given, it is still possible to specify what the result
of the output should be. This is done by simply assigning the
desired <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/index.html#module-numpy" title="(in NumPy v1.13)"><code class="xref py py-obj docutils literal"><span class="pre">numpy</span></code></a> type object to the output argument. For example:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="k">import</span> <span class="n">correlate</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">correlate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">])</span>
<span class="go">array([ 0,  2,  6,  9, 13, 16, 20, 23, 27, 30])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">correlate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">],</span> <span class="n">output</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="go">array([  0. ,   2.5,   6. ,   9.5,  13. ,  16.5,  20. ,  23.5,  27. ,  30.5])</span>
</pre></div>
</div>
</div>
<div class="section" id="filter-functions">
<span id="ndimage-filter-functions"></span><h2>Filter functions<a class="headerlink" href="#filter-functions" title="Permalink to this headline">¶</a></h2>
<p>The functions described in this section all perform some type of spatial
filtering of the input array: the elements in the output are some function
of the values in the neighborhood of the corresponding input element. We refer
to this neighborhood of elements as the filter kernel, which is often
rectangular in shape but may also have an arbitrary footprint. Many
of the functions described below allow you to define the footprint
of the kernel, by passing a mask through the <em>footprint</em> parameter.
For example a cross shaped kernel can be defined as follows:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">footprint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">footprint</span>
<span class="go">array([[0, 1, 0],</span>
<span class="go">       [1, 1, 1],</span>
<span class="go">       [0, 1, 0]])</span>
</pre></div>
</div>
<p>Usually the origin of the kernel is at the center calculated by
dividing the dimensions of the kernel shape by two. For instance,
the origin of a one-dimensional kernel of length three is at the
second element. Take for example the correlation of a
one-dimensional array with a filter of length 3 consisting of
ones:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="k">import</span> <span class="n">correlate1d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">correlate1d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">array([0, 0, 1, 1, 1, 0, 0])</span>
</pre></div>
</div>
<p>Sometimes it is convenient to choose a different origin for the
kernel. For this reason most functions support the <em>origin</em>
parameter which gives the origin of the filter relative to its
center. For example:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">correlate1d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">origin</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([0, 1, 1, 1, 0, 0, 0])</span>
</pre></div>
</div>
<p>The effect is a shift of the result towards the left. This feature
will not be needed very often, but it may be useful especially for
filters that have an even size. A good example is the calculation
of backward and forward differences:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">correlate1d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>               <span class="c1"># backward difference</span>
<span class="go">array([ 0,  0,  1,  0,  0, -1,  0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">correlate1d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">origin</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># forward difference</span>
<span class="go">array([ 0,  1,  0,  0, -1,  0,  0])</span>
</pre></div>
</div>
<p>We could also have calculated the forward difference as follows:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">correlate1d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">array([ 0,  1,  0,  0, -1,  0,  0])</span>
</pre></div>
</div>
<p>However, using the origin parameter instead of a larger kernel is
more efficient. For multidimensional kernels <em>origin</em> can be a
number, in which case the origin is assumed to be equal along all
axes, or a sequence giving the origin along each axis.</p>
<p>Since the output elements are a function of elements in the
neighborhood of the input elements, the borders of the array need to
be dealt with appropriately by providing the values outside the
borders. This is done by assuming that the arrays are extended beyond
their boundaries according certain boundary conditions. In the
functions described below, the boundary conditions can be selected
using the <em>mode</em> parameter which must be a string with the name of the
boundary condition. The following boundary conditions are currently
supported:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="55%" />
<col width="30%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>“nearest”</td>
<td>Use the value at the boundary</td>
<td>[1 2 3]-&gt;[1 1 2 3 3]</td>
</tr>
<tr class="row-even"><td>“wrap”</td>
<td>Periodically replicate the array</td>
<td>[1 2 3]-&gt;[3 1 2 3 1]</td>
</tr>
<tr class="row-odd"><td>“reflect”</td>
<td>Reflect the array at the boundary</td>
<td>[1 2 3]-&gt;[1 1 2 3 3]</td>
</tr>
<tr class="row-even"><td>“constant”</td>
<td>Use a constant value, default is 0.0</td>
<td>[1 2 3]-&gt;[0 1 2 3 0]</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The “constant” mode is special since it needs an additional
parameter to specify the constant value that should be used.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The easiest way to implement such boundary conditions would be to
copy the data to a larger array and extend the data at the borders
according to the boundary conditions. For large arrays and large
filter kernels, this would be very memory consuming, and the
functions described below therefore use a different approach that
does not require allocating large temporary buffers.</p>
</div>
<div class="section" id="correlation-and-convolution">
<h3>Correlation and convolution<a class="headerlink" href="#correlation-and-convolution" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">The <a class="reference internal" href="../generated/scipy.ndimage.correlate1d.html#scipy.ndimage.correlate1d" title="scipy.ndimage.correlate1d"><code class="xref py py-func docutils literal"><span class="pre">correlate1d</span></code></a> function calculates a one-dimensional
correlation along the given axis. The lines of the array along the
given axis are correlated with the given <em>weights</em>. The <em>weights</em>
parameter must be a one-dimensional sequences of numbers.</p>
</li>
<li><p class="first">The function <a class="reference internal" href="../generated/scipy.ndimage.correlate.html#scipy.ndimage.correlate" title="scipy.ndimage.correlate"><code class="xref py py-func docutils literal"><span class="pre">correlate</span></code></a> implements multidimensional
correlation of the input array with a given kernel.</p>
</li>
<li><p class="first">The <a class="reference internal" href="../generated/scipy.ndimage.convolve1d.html#scipy.ndimage.convolve1d" title="scipy.ndimage.convolve1d"><code class="xref py py-func docutils literal"><span class="pre">convolve1d</span></code></a> function calculates a one-dimensional
convolution along the given axis. The lines of the array along the
given axis are convoluted with the given <em>weights</em>. The <em>weights</em>
parameter must be a one-dimensional sequences of numbers.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A convolution is essentially a correlation after mirroring the
kernel. As a result, the <em>origin</em> parameter behaves differently
than in the case of a correlation: the result is shifted in the
opposite directions.</p>
</div>
</li>
<li><p class="first">The function <a class="reference internal" href="../generated/scipy.ndimage.convolve.html#scipy.ndimage.convolve" title="scipy.ndimage.convolve"><code class="xref py py-func docutils literal"><span class="pre">convolve</span></code></a> implements multidimensional
convolution of the input array with a given kernel.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A convolution is essentially a correlation after mirroring the
kernel. As a result, the <em>origin</em> parameter behaves differently
than in the case of a correlation: the results is shifted in the
opposite direction.</p>
</div>
</li>
</ul>
</div>
<div class="section" id="smoothing-filters">
<span id="ndimage-filter-functions-smoothing"></span><h3>Smoothing filters<a class="headerlink" href="#smoothing-filters" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">The <a class="reference internal" href="../generated/scipy.ndimage.gaussian_filter1d.html#scipy.ndimage.gaussian_filter1d" title="scipy.ndimage.gaussian_filter1d"><code class="xref py py-func docutils literal"><span class="pre">gaussian_filter1d</span></code></a> function implements a one-dimensional
Gaussian filter. The standard-deviation of the Gaussian filter is
passed through the parameter <em>sigma</em>. Setting <em>order</em> = 0
corresponds to convolution with a Gaussian kernel. An order of 1, 2,
or 3 corresponds to convolution with the first, second or third
derivatives of a Gaussian. Higher order derivatives are not
implemented.</p>
</li>
<li><p class="first">The <a class="reference internal" href="../generated/scipy.ndimage.gaussian_filter.html#scipy.ndimage.gaussian_filter" title="scipy.ndimage.gaussian_filter"><code class="xref py py-func docutils literal"><span class="pre">gaussian_filter</span></code></a> function implements a multidimensional
Gaussian filter. The standard-deviations of the Gaussian filter
along each axis are passed through the parameter <em>sigma</em> as a
sequence or numbers. If <em>sigma</em> is not a sequence but a single
number, the standard deviation of the filter is equal along all
directions. The order of the filter can be specified separately for
each axis. An order of 0 corresponds to convolution with a Gaussian
kernel. An order of 1, 2, or 3 corresponds to convolution with the
first, second or third derivatives of a Gaussian. Higher order
derivatives are not implemented. The <em>order</em> parameter must be a
number, to specify the same order for all axes, or a sequence of
numbers to specify a different order for each axis.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The multidimensional filter is implemented as a sequence of
one-dimensional Gaussian filters. The intermediate arrays are
stored in the same data type as the output.  Therefore, for
output types with a lower precision, the results may be imprecise
because intermediate results may be stored with insufficient
precision. This can be prevented by specifying a more precise
output type.</p>
</div>
</li>
<li><p class="first">The <a class="reference internal" href="../generated/scipy.ndimage.uniform_filter1d.html#scipy.ndimage.uniform_filter1d" title="scipy.ndimage.uniform_filter1d"><code class="xref py py-func docutils literal"><span class="pre">uniform_filter1d</span></code></a> function calculates a one-dimensional
uniform filter of the given <em>size</em> along the given axis.</p>
</li>
<li><p class="first">The <a class="reference internal" href="../generated/scipy.ndimage.uniform_filter.html#scipy.ndimage.uniform_filter" title="scipy.ndimage.uniform_filter"><code class="xref py py-func docutils literal"><span class="pre">uniform_filter</span></code></a> implements a multidimensional uniform
filter. The sizes of the uniform filter are given for each axis as a
sequence of integers by the <em>size</em> parameter. If <em>size</em> is not a
sequence, but a single number, the sizes along all axis are assumed
to be equal.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The multidimensional filter is implemented as a sequence of
one-dimensional uniform filters. The intermediate arrays are
stored in the same data type as the output. Therefore, for output
types with a lower precision, the results may be imprecise
because intermediate results may be stored with insufficient
precision. This can be prevented by specifying a more precise
output type.</p>
</div>
</li>
</ul>
</div>
<div class="section" id="filters-based-on-order-statistics">
<h3>Filters based on order statistics<a class="headerlink" href="#filters-based-on-order-statistics" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>The <a class="reference internal" href="../generated/scipy.ndimage.minimum_filter1d.html#scipy.ndimage.minimum_filter1d" title="scipy.ndimage.minimum_filter1d"><code class="xref py py-func docutils literal"><span class="pre">minimum_filter1d</span></code></a> function calculates a one-dimensional
minimum filter of given <em>size</em> along the given axis.</li>
<li>The <a class="reference internal" href="../generated/scipy.ndimage.maximum_filter1d.html#scipy.ndimage.maximum_filter1d" title="scipy.ndimage.maximum_filter1d"><code class="xref py py-func docutils literal"><span class="pre">maximum_filter1d</span></code></a> function calculates a one-dimensional
maximum filter of given <em>size</em> along the given axis.</li>
<li>The <a class="reference internal" href="../generated/scipy.ndimage.minimum_filter.html#scipy.ndimage.minimum_filter" title="scipy.ndimage.minimum_filter"><code class="xref py py-func docutils literal"><span class="pre">minimum_filter</span></code></a> function calculates a multidimensional
minimum filter. Either the sizes of a rectangular kernel or the
footprint of the kernel must be provided. The <em>size</em> parameter, if
provided, must be a sequence of sizes or a single number in which
case the size of the filter is assumed to be equal along each axis.
The <em>footprint</em>, if provided, must be an array that defines the
shape of the kernel by its non-zero elements.</li>
<li>The <a class="reference internal" href="../generated/scipy.ndimage.maximum_filter.html#scipy.ndimage.maximum_filter" title="scipy.ndimage.maximum_filter"><code class="xref py py-func docutils literal"><span class="pre">maximum_filter</span></code></a> function calculates a multidimensional
maximum filter. Either the sizes of a rectangular kernel or the
footprint of the kernel must be provided. The <em>size</em> parameter, if
provided, must be a sequence of sizes or a single number in which
case the size of the filter is assumed to be equal along each axis.
The <em>footprint</em>, if provided, must be an array that defines the
shape of the kernel by its non-zero elements.</li>
<li>The <a class="reference internal" href="../generated/scipy.ndimage.rank_filter.html#scipy.ndimage.rank_filter" title="scipy.ndimage.rank_filter"><code class="xref py py-func docutils literal"><span class="pre">rank_filter</span></code></a> function calculates a multidimensional rank
filter. The <em>rank</em> may be less then zero, i.e., <em>rank</em> = -1
indicates the largest element. Either the sizes of a rectangular
kernel or the footprint of the kernel must be provided. The <em>size</em>
parameter, if provided, must be a sequence of sizes or a single
number in which case the size of the filter is assumed to be equal
along each axis. The <em>footprint</em>, if provided, must be an array that
defines the shape of the kernel by its non-zero elements.</li>
<li>The <a class="reference internal" href="../generated/scipy.ndimage.percentile_filter.html#scipy.ndimage.percentile_filter" title="scipy.ndimage.percentile_filter"><code class="xref py py-func docutils literal"><span class="pre">percentile_filter</span></code></a> function calculates a multidimensional
percentile filter. The <em>percentile</em> may be less then zero, i.e.,
<em>percentile</em> = -20 equals <em>percentile</em> = 80. Either the sizes of a
rectangular kernel or the footprint of the kernel must be provided.
The <em>size</em> parameter, if provided, must be a sequence of sizes or a
single number in which case the size of the filter is assumed to be
equal along each axis. The <em>footprint</em>, if provided, must be an
array that defines the shape of the kernel by its non-zero elements.</li>
<li>The <a class="reference internal" href="../generated/scipy.ndimage.median_filter.html#scipy.ndimage.median_filter" title="scipy.ndimage.median_filter"><code class="xref py py-func docutils literal"><span class="pre">median_filter</span></code></a> function calculates a multidimensional
median filter. Either the sizes of a rectangular kernel or the
footprint of the kernel must be provided. The <em>size</em> parameter, if
provided, must be a sequence of sizes or a single number in which
case the size of the filter is assumed to be equal along each
axis. The <em>footprint</em> if provided, must be an array that defines the
shape of the kernel by its non-zero elements.</li>
</ul>
</div>
<div class="section" id="derivatives">
<h3>Derivatives<a class="headerlink" href="#derivatives" title="Permalink to this headline">¶</a></h3>
<p>Derivative filters can be constructed in several ways. The function
<a class="reference internal" href="../generated/scipy.ndimage.gaussian_filter1d.html#scipy.ndimage.gaussian_filter1d" title="scipy.ndimage.gaussian_filter1d"><code class="xref py py-func docutils literal"><span class="pre">gaussian_filter1d</span></code></a> described in
<a class="reference internal" href="#ndimage-filter-functions-smoothing"><span class="std std-ref">Smoothing filters</span></a> can be used to calculate
derivatives along a given axis using the <em>order</em> parameter. Other
derivative filters are the Prewitt and Sobel filters:</p>
<ul class="simple">
<li>The <a class="reference internal" href="../generated/scipy.ndimage.prewitt.html#scipy.ndimage.prewitt" title="scipy.ndimage.prewitt"><code class="xref py py-func docutils literal"><span class="pre">prewitt</span></code></a> function calculates a derivative along the given
axis.</li>
<li>The <a class="reference internal" href="../generated/scipy.ndimage.sobel.html#scipy.ndimage.sobel" title="scipy.ndimage.sobel"><code class="xref py py-func docutils literal"><span class="pre">sobel</span></code></a> function calculates a derivative along the given
axis.</li>
</ul>
<p>The Laplace filter is calculated by the sum of the second derivatives
along all axes. Thus, different Laplace filters can be constructed
using different second derivative functions. Therefore we provide a
general function that takes a function argument to calculate the
second derivative along a given direction.</p>
<ul>
<li><p class="first">The function <a class="reference internal" href="../generated/scipy.ndimage.generic_laplace.html#scipy.ndimage.generic_laplace" title="scipy.ndimage.generic_laplace"><code class="xref py py-func docutils literal"><span class="pre">generic_laplace</span></code></a> calculates a laplace filter
using the function passed through <code class="xref py py-func docutils literal"><span class="pre">derivative2</span></code> to calculate
second derivatives. The function <code class="xref py py-func docutils literal"><span class="pre">derivative2</span></code> should have the
following signature</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">derivative2</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="p">,</span> <span class="o">*</span><span class="n">extra_arguments</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_keywords</span><span class="p">)</span>
</pre></div>
</div>
<p>It should calculate the second derivative along the dimension
<em>axis</em>. If <em>output</em> is not <code class="docutils literal"><span class="pre">None</span></code> it should use that for the
output and return None, otherwise it should return the
result. <em>mode</em>, <em>cval</em> have the usual meaning.</p>
<p>The <em>extra_arguments</em> and <em>extra_keywords</em> arguments can be used
to pass a tuple of extra arguments and a dictionary of named
arguments that are passed to <code class="xref py py-func docutils literal"><span class="pre">derivative2</span></code> at each call.</p>
<p>For example</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">d2</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">correlate1d</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="k">import</span> <span class="n">generic_laplace</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generic_laplace</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">d2</span><span class="p">)</span>
<span class="go">array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1., -4.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.]])</span>
</pre></div>
</div>
<p>To demonstrate the use of the <em>extra_arguments</em> argument we could do</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">d2</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">correlate1d</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="p">,</span> <span class="mi">0</span><span class="p">,)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generic_laplace</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">extra_arguments</span> <span class="o">=</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],))</span>
<span class="go">array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1., -4.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.]])</span>
</pre></div>
</div>
<p>or</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">generic_laplace</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">extra_keywords</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;weights&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]})</span>
<span class="go">array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1., -4.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.]])</span>
</pre></div>
</div>
</li>
</ul>
<p>The following two functions are implemented using
<a class="reference internal" href="../generated/scipy.ndimage.generic_laplace.html#scipy.ndimage.generic_laplace" title="scipy.ndimage.generic_laplace"><code class="xref py py-func docutils literal"><span class="pre">generic_laplace</span></code></a> by providing appropriate functions for the
second derivative function:</p>
<ul class="simple">
<li>The function <a class="reference internal" href="../generated/scipy.ndimage.laplace.html#scipy.ndimage.laplace" title="scipy.ndimage.laplace"><code class="xref py py-func docutils literal"><span class="pre">laplace</span></code></a> calculates the Laplace using discrete
differentiation for the second derivative (i.e. convolution with
<code class="docutils literal"><span class="pre">[1,</span> <span class="pre">-2,</span> <span class="pre">1]</span></code>).</li>
<li>The function <a class="reference internal" href="../generated/scipy.ndimage.gaussian_laplace.html#scipy.ndimage.gaussian_laplace" title="scipy.ndimage.gaussian_laplace"><code class="xref py py-func docutils literal"><span class="pre">gaussian_laplace</span></code></a> calculates the Laplace filter
using <a class="reference internal" href="../generated/scipy.ndimage.gaussian_filter.html#scipy.ndimage.gaussian_filter" title="scipy.ndimage.gaussian_filter"><code class="xref py py-func docutils literal"><span class="pre">gaussian_filter</span></code></a> to calculate the second
derivatives. The standard-deviations of the Gaussian filter along
each axis are passed through the parameter <em>sigma</em> as a sequence or
numbers. If <em>sigma</em> is not a sequence but a single number, the
standard deviation of the filter is equal along all directions.</li>
</ul>
<p>The gradient magnitude is defined as the square root of the sum of the
squares of the gradients in all directions. Similar to the generic
Laplace function there is a <a class="reference internal" href="../generated/scipy.ndimage.generic_gradient_magnitude.html#scipy.ndimage.generic_gradient_magnitude" title="scipy.ndimage.generic_gradient_magnitude"><code class="xref py py-func docutils literal"><span class="pre">generic_gradient_magnitude</span></code></a>
function that calculats the gradient magnitude of an array.</p>
<ul>
<li><p class="first">The function <a class="reference internal" href="../generated/scipy.ndimage.generic_gradient_magnitude.html#scipy.ndimage.generic_gradient_magnitude" title="scipy.ndimage.generic_gradient_magnitude"><code class="xref py py-func docutils literal"><span class="pre">generic_gradient_magnitude</span></code></a> calculates a
gradient magnitude using the function passed through
<code class="xref py py-func docutils literal"><span class="pre">derivative</span></code> to calculate first derivatives. The function
<code class="xref py py-func docutils literal"><span class="pre">derivative</span></code> should have the following signature</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">derivative</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="p">,</span> <span class="o">*</span><span class="n">extra_arguments</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_keywords</span><span class="p">)</span>
</pre></div>
</div>
<p>It should calculate the derivative along the dimension <em>axis</em>. If
<em>output</em> is not None it should use that for the output and return
None, otherwise it should return the result. <em>mode</em>, <em>cval</em> have the
usual meaning.</p>
<p>The <em>extra_arguments</em> and <em>extra_keywords</em> arguments can be used to
pass a tuple of extra arguments and a dictionary of named arguments
that are passed to <em>derivative</em> at each call.</p>
<p>For example, the <a class="reference internal" href="../generated/scipy.ndimage.sobel.html#scipy.ndimage.sobel" title="scipy.ndimage.sobel"><code class="xref py py-func docutils literal"><span class="pre">sobel</span></code></a> function fits the required signature</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="k">import</span> <span class="n">sobel</span><span class="p">,</span> <span class="n">generic_gradient_magnitude</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generic_gradient_magnitude</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">sobel</span><span class="p">)</span>
<span class="go">array([[ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ],</span>
<span class="go">       [ 0.        ,  1.41421356,  2.        ,  1.41421356,  0.        ],</span>
<span class="go">       [ 0.        ,  2.        ,  0.        ,  2.        ,  0.        ],</span>
<span class="go">       [ 0.        ,  1.41421356,  2.        ,  1.41421356,  0.        ],</span>
<span class="go">       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ]])</span>
</pre></div>
</div>
<p>See the documentation of <a class="reference internal" href="../generated/scipy.ndimage.generic_laplace.html#scipy.ndimage.generic_laplace" title="scipy.ndimage.generic_laplace"><code class="xref py py-func docutils literal"><span class="pre">generic_laplace</span></code></a> for examples of
using the <em>extra_arguments</em> and <em>extra_keywords</em> arguments.</p>
</li>
</ul>
<p>The <a class="reference internal" href="../generated/scipy.ndimage.sobel.html#scipy.ndimage.sobel" title="scipy.ndimage.sobel"><code class="xref py py-func docutils literal"><span class="pre">sobel</span></code></a> and <a class="reference internal" href="../generated/scipy.ndimage.prewitt.html#scipy.ndimage.prewitt" title="scipy.ndimage.prewitt"><code class="xref py py-func docutils literal"><span class="pre">prewitt</span></code></a> functions fit the required
signature and can therefore directly be used with
<a class="reference internal" href="../generated/scipy.ndimage.generic_gradient_magnitude.html#scipy.ndimage.generic_gradient_magnitude" title="scipy.ndimage.generic_gradient_magnitude"><code class="xref py py-func docutils literal"><span class="pre">generic_gradient_magnitude</span></code></a>.</p>
<ul class="simple">
<li>The function <a class="reference internal" href="../generated/scipy.ndimage.gaussian_gradient_magnitude.html#scipy.ndimage.gaussian_gradient_magnitude" title="scipy.ndimage.gaussian_gradient_magnitude"><code class="xref py py-func docutils literal"><span class="pre">gaussian_gradient_magnitude</span></code></a> calculates the
gradient magnitude using <a class="reference internal" href="../generated/scipy.ndimage.gaussian_filter.html#scipy.ndimage.gaussian_filter" title="scipy.ndimage.gaussian_filter"><code class="xref py py-func docutils literal"><span class="pre">gaussian_filter</span></code></a> to calculate the
first derivatives. The standard-deviations of the Gaussian filter
along each axis are passed through the parameter <em>sigma</em> as a
sequence or numbers. If <em>sigma</em> is not a sequence but a single
number, the standard deviation of the filter is equal along all
directions.</li>
</ul>
</div>
<div class="section" id="generic-filter-functions">
<span id="ndimage-genericfilters"></span><h3>Generic filter functions<a class="headerlink" href="#generic-filter-functions" title="Permalink to this headline">¶</a></h3>
<p>To implement filter functions, generic functions can be used that
accept a callable object that implements the filtering operation. The
iteration over the input and output arrays is handled by these generic
functions, along with such details as the implementation of the
boundary conditions. Only a callable object implementing a callback
function that does the actual filtering work must be provided. The
callback function can also be written in C and passed using a
<a class="reference external" href="https://docs.python.org/dev/c-api/capsule.html#c.PyCapsule" title="(in Python v3.7)"><code class="xref c c-type docutils literal"><span class="pre">PyCapsule</span></code></a> (see <a class="reference internal" href="#ndimage-ccallbacks"><span class="std std-ref">Extending scipy.ndimage in C</span></a> for more
information).</p>
<ul>
<li><p class="first">The <a class="reference internal" href="../generated/scipy.ndimage.generic_filter1d.html#scipy.ndimage.generic_filter1d" title="scipy.ndimage.generic_filter1d"><code class="xref py py-func docutils literal"><span class="pre">generic_filter1d</span></code></a> function implements a generic
one-dimensional filter function, where the actual filtering
operation must be supplied as a python function (or other callable
object). The <a class="reference internal" href="../generated/scipy.ndimage.generic_filter1d.html#scipy.ndimage.generic_filter1d" title="scipy.ndimage.generic_filter1d"><code class="xref py py-func docutils literal"><span class="pre">generic_filter1d</span></code></a> function iterates over the
lines of an array and calls <code class="xref py py-func docutils literal"><span class="pre">function</span></code> at each line. The
arguments that are passed to <code class="xref py py-func docutils literal"><span class="pre">function</span></code> are one-dimensional
arrays of the <code class="xref c c-type docutils literal"><span class="pre">tFloat64</span></code> type. The first contains the values
of the current line.  It is extended at the beginning end the end,
according to the <em>filter_size</em> and <em>origin</em> arguments. The second
array should be modified in-place to provide the output values of
the line. For example consider a correlation along one dimension:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">correlate1d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">array([[ 3,  8, 14, 17],</span>
<span class="go">       [27, 32, 38, 41],</span>
<span class="go">       [51, 56, 62, 65]])</span>
</pre></div>
</div>
<p>The same operation can be implemented using <a class="reference internal" href="../generated/scipy.ndimage.generic_filter1d.html#scipy.ndimage.generic_filter1d" title="scipy.ndimage.generic_filter1d"><code class="xref py py-func docutils literal"><span class="pre">generic_filter1d</span></code></a>
as follows:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">fnc</span><span class="p">(</span><span class="n">iline</span><span class="p">,</span> <span class="n">oline</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">oline</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">iline</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">iline</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">iline</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="k">import</span> <span class="n">generic_filter1d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generic_filter1d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fnc</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">array([[ 3,  8, 14, 17],</span>
<span class="go">       [27, 32, 38, 41],</span>
<span class="go">       [51, 56, 62, 65]])</span>
</pre></div>
</div>
<p>Here the origin of the kernel was (by default) assumed to be in the
middle of the filter of length 3. Therefore, each input line was
extended by one value at the beginning and at the end, before the
function was called.</p>
<p>Optionally extra arguments can be defined and passed to the filter
function. The <em>extra_arguments</em> and <em>extra_keywords</em> arguments can
be used to pass a tuple of extra arguments and/or a dictionary of
named arguments that are passed to derivative at each call. For
example, we can pass the parameters of our filter as an argument</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">fnc</span><span class="p">(</span><span class="n">iline</span><span class="p">,</span> <span class="n">oline</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">oline</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">iline</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">iline</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">iline</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generic_filter1d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fnc</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">extra_arguments</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">array([[ 3,  8, 14, 17],</span>
<span class="go">       [27, 32, 38, 41],</span>
<span class="go">       [51, 56, 62, 65]])</span>
</pre></div>
</div>
<p>or</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">generic_filter1d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fnc</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">extra_keywords</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">})</span>
<span class="go">array([[ 3,  8, 14, 17],</span>
<span class="go">       [27, 32, 38, 41],</span>
<span class="go">       [51, 56, 62, 65]])</span>
</pre></div>
</div>
</li>
<li><p class="first">The <a class="reference internal" href="../generated/scipy.ndimage.generic_filter.html#scipy.ndimage.generic_filter" title="scipy.ndimage.generic_filter"><code class="xref py py-func docutils literal"><span class="pre">generic_filter</span></code></a> function implements a generic filter
function, where the actual filtering operation must be supplied as a
python function (or other callable object). The
<a class="reference internal" href="../generated/scipy.ndimage.generic_filter.html#scipy.ndimage.generic_filter" title="scipy.ndimage.generic_filter"><code class="xref py py-func docutils literal"><span class="pre">generic_filter</span></code></a> function iterates over the array and calls
<code class="xref py py-func docutils literal"><span class="pre">function</span></code> at each element. The argument of <code class="xref py py-func docutils literal"><span class="pre">function</span></code>
is a one-dimensional array of the <code class="xref c c-type docutils literal"><span class="pre">tFloat64</span></code> type, that
contains the values around the current element that are within the
footprint of the filter. The function should return a single value
that can be converted to a double precision number. For example
consider a correlation:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">correlate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="go">array([[ 0,  3,  7, 11],</span>
<span class="go">       [12, 15, 19, 23],</span>
<span class="go">       [28, 31, 35, 39]])</span>
</pre></div>
</div>
<p>The same operation can be implemented using <em>generic_filter</em> as
follows:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">fnc</span><span class="p">(</span><span class="n">buffer</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="k">import</span> <span class="n">generic_filter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generic_filter</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fnc</span><span class="p">,</span> <span class="n">footprint</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="go">array([[ 0,  3,  7, 11],</span>
<span class="go">       [12, 15, 19, 23],</span>
<span class="go">       [28, 31, 35, 39]])</span>
</pre></div>
</div>
<p>Here a kernel footprint was specified that contains only two
elements. Therefore the filter function receives a buffer of length
equal to two, which was multiplied with the proper weights and the
result summed.</p>
<p>When calling <a class="reference internal" href="../generated/scipy.ndimage.generic_filter.html#scipy.ndimage.generic_filter" title="scipy.ndimage.generic_filter"><code class="xref py py-func docutils literal"><span class="pre">generic_filter</span></code></a>, either the sizes of a
rectangular kernel or the footprint of the kernel must be
provided. The <em>size</em> parameter, if provided, must be a sequence of
sizes or a single number in which case the size of the filter is
assumed to be equal along each axis. The <em>footprint</em>, if provided,
must be an array that defines the shape of the kernel by its
non-zero elements.</p>
<p>Optionally extra arguments can be defined and passed to the filter
function. The <em>extra_arguments</em> and <em>extra_keywords</em> arguments can
be used to pass a tuple of extra arguments and/or a dictionary of
named arguments that are passed to derivative at each call. For
example, we can pass the parameters of our filter as an argument</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">fnc</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">*</span> <span class="n">weights</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generic_filter</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fnc</span><span class="p">,</span> <span class="n">footprint</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">extra_arguments</span> <span class="o">=</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],))</span>
<span class="go">array([[ 0,  3,  7, 11],</span>
<span class="go">       [12, 15, 19, 23],</span>
<span class="go">       [28, 31, 35, 39]])</span>
</pre></div>
</div>
<p>or</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">generic_filter</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fnc</span><span class="p">,</span> <span class="n">footprint</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">extra_keywords</span><span class="o">=</span> <span class="p">{</span><span class="s1">&#39;weights&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>
<span class="go">array([[ 0,  3,  7, 11],</span>
<span class="go">       [12, 15, 19, 23],</span>
<span class="go">       [28, 31, 35, 39]])</span>
</pre></div>
</div>
</li>
</ul>
<p>These functions iterate over the lines or elements starting at the
last axis, i.e. the last index changes the fastest. This order of
iteration is guaranteed for the case that it is important to adapt the
filter depending on spatial location. Here is an example of using a
class that implements the filter and keeps track of the current
coordinates while iterating. It performs the same filter operation as
described above for <a class="reference internal" href="../generated/scipy.ndimage.generic_filter.html#scipy.ndimage.generic_filter" title="scipy.ndimage.generic_filter"><code class="xref py py-func docutils literal"><span class="pre">generic_filter</span></code></a>, but additionally prints
the current coordinates:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">fnc_class</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
<span class="gp">... </span>        <span class="c1"># store the shape:</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>
<span class="gp">... </span>        <span class="c1"># initialize the coordinates:</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buffer</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">)</span>
<span class="gp">... </span>        <span class="c1"># calculate the next coordinates:</span>
<span class="gp">... </span>        <span class="n">axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
<span class="gp">... </span>        <span class="n">axes</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">... </span>                <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span>                <span class="k">break</span>
<span class="gp">... </span>            <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>                <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">result</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fnc</span> <span class="o">=</span> <span class="n">fnc_class</span><span class="p">(</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generic_filter</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fnc</span><span class="o">.</span><span class="n">filter</span><span class="p">,</span> <span class="n">footprint</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="go">[0, 0]</span>
<span class="go">[0, 1]</span>
<span class="go">[0, 2]</span>
<span class="go">[0, 3]</span>
<span class="go">[1, 0]</span>
<span class="go">[1, 1]</span>
<span class="go">[1, 2]</span>
<span class="go">[1, 3]</span>
<span class="go">[2, 0]</span>
<span class="go">[2, 1]</span>
<span class="go">[2, 2]</span>
<span class="go">[2, 3]</span>
<span class="go">array([[ 0,  3,  7, 11],</span>
<span class="go">       [12, 15, 19, 23],</span>
<span class="go">       [28, 31, 35, 39]])</span>
</pre></div>
</div>
<p>For the <a class="reference internal" href="../generated/scipy.ndimage.generic_filter1d.html#scipy.ndimage.generic_filter1d" title="scipy.ndimage.generic_filter1d"><code class="xref py py-func docutils literal"><span class="pre">generic_filter1d</span></code></a> function the same approach works,
except that this function does not iterate over the axis that is being
filtered. The example for <a class="reference internal" href="../generated/scipy.ndimage.generic_filter1d.html#scipy.ndimage.generic_filter1d" title="scipy.ndimage.generic_filter1d"><code class="xref py py-func docutils literal"><span class="pre">generic_filter1d</span></code></a> then becomes this:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">fnc1d_class</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>        <span class="c1"># store the filter axis:</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span>
<span class="gp">... </span>        <span class="c1"># store the shape:</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>
<span class="gp">... </span>        <span class="c1"># initialize the coordinates:</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iline</span><span class="p">,</span> <span class="n">oline</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">oline</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">iline</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">iline</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">iline</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">)</span>
<span class="gp">... </span>        <span class="c1"># calculate the next coordinates:</span>
<span class="gp">... </span>        <span class="n">axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
<span class="gp">... </span>        <span class="c1"># skip the filter axis:</span>
<span class="gp">... </span>        <span class="k">del</span> <span class="n">axes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">]</span>
<span class="gp">... </span>        <span class="n">axes</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">... </span>                <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span>                <span class="k">break</span>
<span class="gp">... </span>            <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>                <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fnc</span> <span class="o">=</span> <span class="n">fnc1d_class</span><span class="p">(</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generic_filter1d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fnc</span><span class="o">.</span><span class="n">filter</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[0, 0]</span>
<span class="go">[1, 0]</span>
<span class="go">[2, 0]</span>
<span class="go">array([[ 3,  8, 14, 17],</span>
<span class="go">       [27, 32, 38, 41],</span>
<span class="go">       [51, 56, 62, 65]])</span>
</pre></div>
</div>
</div>
<div class="section" id="fourier-domain-filters">
<h3>Fourier domain filters<a class="headerlink" href="#fourier-domain-filters" title="Permalink to this headline">¶</a></h3>
<p>The functions described in this section perform filtering
operations in the Fourier domain. Thus, the input array of such a
function should be compatible with an inverse Fourier transform
function, such as the functions from the <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/routines.fft.html#module-numpy.fft" title="(in NumPy v1.13)"><code class="xref py py-mod docutils literal"><span class="pre">numpy.fft</span></code></a> module. We
therefore have to deal with arrays that may be the result of a real
or a complex Fourier transform. In the case of a real Fourier
transform only half of the of the symmetric complex transform is
stored. Additionally, it needs to be known what the length of the
axis was that was transformed by the real fft. The functions
described here provide a parameter <em>n</em> that in the case of a real
transform must be equal to the length of the real transform axis
before transformation. If this parameter is less than zero, it is
assumed that the input array was the result of a complex Fourier
transform. The parameter <em>axis</em> can be used to indicate along which
axis the real transform was executed.</p>
<ul class="simple">
<li>The <a class="reference internal" href="../generated/scipy.ndimage.fourier_shift.html#scipy.ndimage.fourier_shift" title="scipy.ndimage.fourier_shift"><code class="xref py py-func docutils literal"><span class="pre">fourier_shift</span></code></a> function multiplies the input array with
the multidimensional Fourier transform of a shift operation for the
given shift. The <em>shift</em> parameter is a sequences of shifts for each
dimension, or a single value for all dimensions.</li>
<li>The <a class="reference internal" href="../generated/scipy.ndimage.fourier_gaussian.html#scipy.ndimage.fourier_gaussian" title="scipy.ndimage.fourier_gaussian"><code class="xref py py-func docutils literal"><span class="pre">fourier_gaussian</span></code></a> function multiplies the input array
with the multidimensional Fourier transform of a Gaussian filter
with given standard-deviations <em>sigma</em>. The <em>sigma</em> parameter is a
sequences of values for each dimension, or a single value for all
dimensions.</li>
<li>The <a class="reference internal" href="../generated/scipy.ndimage.fourier_uniform.html#scipy.ndimage.fourier_uniform" title="scipy.ndimage.fourier_uniform"><code class="xref py py-func docutils literal"><span class="pre">fourier_uniform</span></code></a> function multiplies the input array with
the multidimensional Fourier transform of a uniform filter with
given sizes <em>size</em>. The <em>size</em> parameter is a sequences of values
for each dimension, or a single value for all dimensions.</li>
<li>The <a class="reference internal" href="../generated/scipy.ndimage.fourier_ellipsoid.html#scipy.ndimage.fourier_ellipsoid" title="scipy.ndimage.fourier_ellipsoid"><code class="xref py py-func docutils literal"><span class="pre">fourier_ellipsoid</span></code></a> function multiplies the input array
with the multidimensional Fourier transform of a elliptically shaped
filter with given sizes <em>size</em>. The <em>size</em> parameter is a sequences
of values for each dimension, or a single value for all dimensions.
This function is only implemented for dimensions 1, 2, and 3.</li>
</ul>
</div>
</div>
<div class="section" id="interpolation-functions">
<span id="ndimage-interpolation"></span><h2>Interpolation functions<a class="headerlink" href="#interpolation-functions" title="Permalink to this headline">¶</a></h2>
<p>This section describes various interpolation functions that are based
on B-spline theory. A good introduction to B-splines can be found
in <a class="footnote-reference" href="#id11" id="id1">[1]</a>.</p>
<div class="section" id="spline-pre-filters">
<h3>Spline pre-filters<a class="headerlink" href="#spline-pre-filters" title="Permalink to this headline">¶</a></h3>
<p>Interpolation using splines of an order larger than 1 requires a
pre-filtering step. The interpolation functions described in section
<a class="reference internal" href="#ndimage-interpolation"><span class="std std-ref">Interpolation functions</span></a> apply pre-filtering by calling
<a class="reference internal" href="../generated/scipy.ndimage.spline_filter.html#scipy.ndimage.spline_filter" title="scipy.ndimage.spline_filter"><code class="xref py py-func docutils literal"><span class="pre">spline_filter</span></code></a>, but they can be instructed not to do this by
setting the <em>prefilter</em> keyword equal to False. This is useful if more
than one interpolation operation is done on the same array. In this
case it is more efficient to do the pre-filtering only once and use a
prefiltered array as the input of the interpolation functions. The
following two functions implement the pre-filtering:</p>
<ul>
<li><p class="first">The <a class="reference internal" href="../generated/scipy.ndimage.spline_filter1d.html#scipy.ndimage.spline_filter1d" title="scipy.ndimage.spline_filter1d"><code class="xref py py-func docutils literal"><span class="pre">spline_filter1d</span></code></a> function calculates a one-dimensional
spline filter along the given axis. An output array can optionally
be provided. The order of the spline must be larger then 1 and less
than 6.</p>
</li>
<li><p class="first">The <a class="reference internal" href="../generated/scipy.ndimage.spline_filter.html#scipy.ndimage.spline_filter" title="scipy.ndimage.spline_filter"><code class="xref py py-func docutils literal"><span class="pre">spline_filter</span></code></a> function calculates a multidimensional
spline filter.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The multidimensional filter is implemented as a sequence of
one-dimensional spline filters. The intermediate arrays are
stored in the same data type as the output. Therefore, if an
output with a limited precision is requested, the results may be
imprecise because intermediate results may be stored with
insufficient precision. This can be prevented by specifying a
output type of high precision.</p>
</div>
</li>
</ul>
</div>
<div class="section" id="id2">
<h3>Interpolation functions<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>Following functions all employ spline interpolation to effect some
type of geometric transformation of the input array. This requires a
mapping of the output coordinates to the input coordinates, and
therefore the possibility arises that input values outside the
boundaries are needed. This problem is solved in the same way as
described in <a class="reference internal" href="#ndimage-filter-functions"><span class="std std-ref">Filter functions</span></a> for the multidimensional
filter functions. Therefore these functions all support a <em>mode</em>
parameter that determines how the boundaries are handled, and a <em>cval</em>
parameter that gives a constant value in case that the ‘constant’ mode
is used.</p>
<ul>
<li><p class="first">The <a class="reference internal" href="../generated/scipy.ndimage.geometric_transform.html#scipy.ndimage.geometric_transform" title="scipy.ndimage.geometric_transform"><code class="xref py py-func docutils literal"><span class="pre">geometric_transform</span></code></a> function applies an arbitrary
geometric transform to the input. The given <em>mapping</em> function is
called at each point in the output to find the corresponding
coordinates in the input. <em>mapping</em> must be a callable object that
accepts a tuple of length equal to the output array rank and returns
the corresponding input coordinates as a tuple of length equal to
the input array rank. The output shape and output type can
optionally be provided. If not given they are equal to the input
shape and type.</p>
<p>For example:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">shift_func</span><span class="p">(</span><span class="n">output_coordinates</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">output_coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">output_coordinates</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="k">import</span> <span class="n">geometric_transform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geometric_transform</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">shift_func</span><span class="p">)</span>
<span class="go">array([[ 0.    ,  0.    ,  0.    ],</span>
<span class="go">       [ 0.    ,  1.3625,  2.7375],</span>
<span class="go">       [ 0.    ,  4.8125,  6.1875],</span>
<span class="go">       [ 0.    ,  8.2625,  9.6375]])</span>
</pre></div>
</div>
<p>Optionally extra arguments can be defined and passed to the filter
function. The <em>extra_arguments</em> and <em>extra_keywords</em> arguments can
be used to pass a tuple of extra arguments and/or a dictionary of
named arguments that are passed to derivative at each call. For
example, we can pass the shifts in our example as arguments</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">shift_func</span><span class="p">(</span><span class="n">output_coordinates</span><span class="p">,</span> <span class="n">s0</span><span class="p">,</span> <span class="n">s1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">output_coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">s0</span><span class="p">,</span> <span class="n">output_coordinates</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">s1</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geometric_transform</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">shift_func</span><span class="p">,</span> <span class="n">extra_arguments</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span>
<span class="go">array([[ 0.    ,  0.    ,  0.    ],</span>
<span class="go">       [ 0.    ,  1.3625,  2.7375],</span>
<span class="go">       [ 0.    ,  4.8125,  6.1875],</span>
<span class="go">       [ 0.    ,  8.2625,  9.6375]])</span>
</pre></div>
</div>
<p>or</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geometric_transform</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">shift_func</span><span class="p">,</span> <span class="n">extra_keywords</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;s0&#39;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;s1&#39;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">})</span>
<span class="go">array([[ 0.    ,  0.    ,  0.    ],</span>
<span class="go">       [ 0.    ,  1.3625,  2.7375],</span>
<span class="go">       [ 0.    ,  4.8125,  6.1875],</span>
<span class="go">       [ 0.    ,  8.2625,  9.6375]])</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The mapping function can also be written in C and passed using a
<a class="reference internal" href="../generated/scipy.LowLevelCallable.html#scipy.LowLevelCallable" title="scipy.LowLevelCallable"><code class="xref py py-obj docutils literal"><span class="pre">scipy.LowLevelCallable</span></code></a>. See <a class="reference internal" href="#ndimage-ccallbacks"><span class="std std-ref">Extending scipy.ndimage in C</span></a> for more
information.</p>
</div>
</li>
<li><p class="first">The function <a class="reference internal" href="../generated/scipy.ndimage.map_coordinates.html#scipy.ndimage.map_coordinates" title="scipy.ndimage.map_coordinates"><code class="xref py py-func docutils literal"><span class="pre">map_coordinates</span></code></a> applies an arbitrary coordinate
transformation using the given array of coordinates. The shape of
the output is derived from that of the coordinate array by dropping
the first axis. The parameter <em>coordinates</em> is used to find for each
point in the output the corresponding coordinates in the input. The
values of <em>coordinates</em> along the first axis are the coordinates in
the input array at which the output value is found.  (See also the
numarray <em class="xref py py-obj">coordinates</em> function.) Since the coordinates may be non-
integer coordinates, the value of the input at these coordinates is
determined by spline interpolation of the requested order.</p>
<p>Here is an example that interpolates a 2D array at <code class="docutils literal"><span class="pre">(0.5,</span> <span class="pre">0.5)</span></code> and
<code class="docutils literal"><span class="pre">(1,</span> <span class="pre">2)</span></code>:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[  0.,   1.,   2.],</span>
<span class="go">       [  3.,   4.,   5.],</span>
<span class="go">       [  6.,   7.,   8.],</span>
<span class="go">       [  9.,  10.,  11.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="k">import</span> <span class="n">map_coordinates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">map_coordinates</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="go">array([ 1.3625,  7.])</span>
</pre></div>
</div>
</li>
<li><p class="first">The <a class="reference internal" href="../generated/scipy.ndimage.affine_transform.html#scipy.ndimage.affine_transform" title="scipy.ndimage.affine_transform"><code class="xref py py-func docutils literal"><span class="pre">affine_transform</span></code></a> function applies an affine
transformation to the input array. The given transformation <em>matrix</em>
and <em>offset</em> are used to find for each point in the output the
corresponding coordinates in the input. The value of the input at
the calculated coordinates is determined by spline interpolation of
the requested order. The transformation <em>matrix</em> must be
two-dimensional or can also be given as a one-dimensional sequence
or array. In the latter case, it is assumed that the matrix is
diagonal. A more efficient interpolation algorithm is then applied
that exploits the separability of the problem. The output shape and
output type can optionally be provided. If not given they are equal
to the input shape and type.</p>
</li>
<li><p class="first">The <a class="reference internal" href="../generated/scipy.ndimage.shift.html#scipy.ndimage.shift" title="scipy.ndimage.shift"><code class="xref py py-func docutils literal"><span class="pre">shift</span></code></a> function returns a shifted version of the input,
using spline interpolation of the requested <em>order</em>.</p>
</li>
<li><p class="first">The <a class="reference internal" href="../generated/scipy.ndimage.zoom.html#scipy.ndimage.zoom" title="scipy.ndimage.zoom"><code class="xref py py-func docutils literal"><span class="pre">zoom</span></code></a> function returns a rescaled version of the input,
using spline interpolation of the requested <em>order</em>.</p>
</li>
<li><p class="first">The <a class="reference internal" href="../generated/scipy.ndimage.rotate.html#scipy.ndimage.rotate" title="scipy.ndimage.rotate"><code class="xref py py-func docutils literal"><span class="pre">rotate</span></code></a> function returns the input array rotated in the
plane defined by the two axes given by the parameter <em>axes</em>, using
spline interpolation of the requested <em>order</em>. The angle must be
given in degrees. If <em>reshape</em> is true, then the size of the output
array is adapted to contain the rotated input.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="morphology">
<span id="ndimage-morphology"></span><h2>Morphology<a class="headerlink" href="#morphology" title="Permalink to this headline">¶</a></h2>
<div class="section" id="binary-morphology">
<span id="ndimage-binary-morphology"></span><h3>Binary morphology<a class="headerlink" href="#binary-morphology" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">The <a class="reference internal" href="../generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure" title="scipy.ndimage.generate_binary_structure"><code class="xref py py-func docutils literal"><span class="pre">generate_binary_structure</span></code></a> functions generates a binary
structuring element for use in binary morphology operations. The
<em>rank</em> of the structure must be provided. The size of the structure
that is returned is equal to three in each direction. The value of
each element is equal to one if the square of the Euclidean distance
from the element to the center is less or equal to
<em>connectivity</em>. For instance, two dimensional 4-connected and
8-connected structures are generated as follows:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="k">import</span> <span class="n">generate_binary_structure</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generate_binary_structure</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">array([[False,  True, False],</span>
<span class="go">       [ True,  True,  True],</span>
<span class="go">       [False,  True, False]], dtype=bool)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generate_binary_structure</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([[ True,  True,  True],</span>
<span class="go">       [ True,  True,  True],</span>
<span class="go">       [ True,  True,  True]], dtype=bool)</span>
</pre></div>
</div>
</li>
</ul>
<p>Most binary morphology functions can be expressed in terms of the
basic operations erosion and dilation.</p>
<ul class="simple">
<li>The <a class="reference internal" href="../generated/scipy.ndimage.binary_erosion.html#scipy.ndimage.binary_erosion" title="scipy.ndimage.binary_erosion"><code class="xref py py-func docutils literal"><span class="pre">binary_erosion</span></code></a> function implements binary erosion of
arrays of arbitrary rank with the given structuring element. The
origin parameter controls the placement of the structuring element
as described in <a class="reference internal" href="#ndimage-filter-functions"><span class="std std-ref">Filter functions</span></a>. If no structuring
element is provided, an element with connectivity equal to one is
generated using <a class="reference internal" href="../generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure" title="scipy.ndimage.generate_binary_structure"><code class="xref py py-func docutils literal"><span class="pre">generate_binary_structure</span></code></a>. The
<em>border_value</em> parameter gives the value of the array outside
boundaries. The erosion is repeated <em>iterations</em> times. If
<em>iterations</em> is less than one, the erosion is repeated until the
result does not change anymore. If a <em>mask</em> array is given, only
those elements with a true value at the corresponding mask element
are modified at each iteration.</li>
<li>The <a class="reference internal" href="../generated/scipy.ndimage.binary_dilation.html#scipy.ndimage.binary_dilation" title="scipy.ndimage.binary_dilation"><code class="xref py py-func docutils literal"><span class="pre">binary_dilation</span></code></a> function implements binary dilation of
arrays of arbitrary rank with the given structuring element. The
origin parameter controls the placement of the structuring element
as described in <a class="reference internal" href="#ndimage-filter-functions"><span class="std std-ref">Filter functions</span></a>. If no structuring
element is provided, an element with connectivity equal to one is
generated using <a class="reference internal" href="../generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure" title="scipy.ndimage.generate_binary_structure"><code class="xref py py-func docutils literal"><span class="pre">generate_binary_structure</span></code></a>. The
<em>border_value</em> parameter gives the value of the array outside
boundaries. The dilation is repeated <em>iterations</em> times. If
<em>iterations</em> is less than one, the dilation is repeated until the
result does not change anymore. If a <em>mask</em> array is given, only
those elements with a true value at the corresponding mask element
are modified at each iteration.</li>
</ul>
<p>Here is an example of using <a class="reference internal" href="../generated/scipy.ndimage.binary_dilation.html#scipy.ndimage.binary_dilation" title="scipy.ndimage.binary_dilation"><code class="xref py py-func docutils literal"><span class="pre">binary_dilation</span></code></a> to find all elements
that touch the border, by repeatedly dilating an empty array from
the border using the data array as the mask:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">struct</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[1, 0, 0, 0, 0],</span>
<span class="go">       [1, 1, 0, 1, 0],</span>
<span class="go">       [0, 0, 1, 1, 0],</span>
<span class="go">       [0, 0, 0, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="k">import</span> <span class="n">binary_dilation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary_dilation</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">struct</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">border_value</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[ True, False, False, False, False],</span>
<span class="go">       [ True,  True, False, False, False],</span>
<span class="go">       [False, False, False, False, False],</span>
<span class="go">       [False, False, False, False, False]], dtype=bool)</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../generated/scipy.ndimage.binary_erosion.html#scipy.ndimage.binary_erosion" title="scipy.ndimage.binary_erosion"><code class="xref py py-func docutils literal"><span class="pre">binary_erosion</span></code></a> and <a class="reference internal" href="../generated/scipy.ndimage.binary_dilation.html#scipy.ndimage.binary_dilation" title="scipy.ndimage.binary_dilation"><code class="xref py py-func docutils literal"><span class="pre">binary_dilation</span></code></a> functions both
have an <em>iterations</em> parameter which allows the erosion or dilation to
be repeated a number of times. Repeating an erosion or a dilation with
a given structure <em>n</em> times is equivalent to an erosion or a dilation
with a structure that is <em>n-1</em> times dilated with itself.  A function
is provided that allows the calculation of a structure that is dilated
a number of times with itself:</p>
<ul>
<li><p class="first">The <a class="reference internal" href="../generated/scipy.ndimage.iterate_structure.html#scipy.ndimage.iterate_structure" title="scipy.ndimage.iterate_structure"><code class="xref py py-func docutils literal"><span class="pre">iterate_structure</span></code></a> function returns a structure by dilation
of the input structure <em>iteration</em> - 1 times with itself.</p>
<p>For instance:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">struct</span> <span class="o">=</span> <span class="n">generate_binary_structure</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">struct</span>
<span class="go">array([[False,  True, False],</span>
<span class="go">       [ True,  True,  True],</span>
<span class="go">       [False,  True, False]], dtype=bool)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="k">import</span> <span class="n">iterate_structure</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iterate_structure</span><span class="p">(</span><span class="n">struct</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([[False, False,  True, False, False],</span>
<span class="go">       [False,  True,  True,  True, False],</span>
<span class="go">       [ True,  True,  True,  True,  True],</span>
<span class="go">       [False,  True,  True,  True, False],</span>
<span class="go">       [False, False,  True, False, False]], dtype=bool)</span>

<span class="go">If the origin of the original structure is equal to 0, then it is</span>
<span class="go">also equal to 0 for the iterated structure. If not, the origin</span>
<span class="go">must also be adapted if the equivalent of the *iterations*</span>
<span class="go">erosions or dilations must be achieved with the iterated</span>
<span class="go">structure. The adapted origin is simply obtained by multiplying</span>
<span class="go">with the number of iterations. For convenience the</span>
<span class="go">:func:`iterate_structure` also returns the adapted origin if the</span>
<span class="go">*origin* parameter is not ``None``:</span>

<span class="go">.. code:: python</span>

<span class="go">   &gt;&gt;&gt; iterate_structure(struct, 2, -1)</span>
<span class="go">   (array([[False, False,  True, False, False],</span>
<span class="go">           [False,  True,  True,  True, False],</span>
<span class="go">           [ True,  True,  True,  True,  True],</span>
<span class="go">           [False,  True,  True,  True, False],</span>
<span class="go">           [False, False,  True, False, False]], dtype=bool), [-2, -2])</span>
</pre></div>
</div>
</li>
</ul>
<p>Other morphology operations can be defined in terms of erosion and d
dilation. The following functions provide a few of these operations
for convenience:</p>
<ul class="simple">
<li>The <a class="reference internal" href="../generated/scipy.ndimage.binary_opening.html#scipy.ndimage.binary_opening" title="scipy.ndimage.binary_opening"><code class="xref py py-func docutils literal"><span class="pre">binary_opening</span></code></a> function implements binary opening of
arrays of arbitrary rank with the given structuring element. Binary
opening is equivalent to a binary erosion followed by a binary
dilation with the same structuring element. The origin parameter
controls the placement of the structuring element as described in
<a class="reference internal" href="#ndimage-filter-functions"><span class="std std-ref">Filter functions</span></a>. If no structuring element is
provided, an element with connectivity equal to one is generated
using <a class="reference internal" href="../generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure" title="scipy.ndimage.generate_binary_structure"><code class="xref py py-func docutils literal"><span class="pre">generate_binary_structure</span></code></a>. The <em>iterations</em> parameter
gives the number of erosions that is performed followed by the same
number of dilations.</li>
<li>The <a class="reference internal" href="../generated/scipy.ndimage.binary_closing.html#scipy.ndimage.binary_closing" title="scipy.ndimage.binary_closing"><code class="xref py py-func docutils literal"><span class="pre">binary_closing</span></code></a> function implements binary closing of
arrays of arbitrary rank with the given structuring element. Binary
closing is equivalent to a binary dilation followed by a binary
erosion with the same structuring element. The origin parameter
controls the placement of the structuring element as described in
<a class="reference internal" href="#ndimage-filter-functions"><span class="std std-ref">Filter functions</span></a>. If no structuring element is
provided, an element with connectivity equal to one is generated
using <a class="reference internal" href="../generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure" title="scipy.ndimage.generate_binary_structure"><code class="xref py py-func docutils literal"><span class="pre">generate_binary_structure</span></code></a>. The <em>iterations</em> parameter
gives the number of dilations that is performed followed by the same
number of erosions.</li>
<li>The <a class="reference internal" href="../generated/scipy.ndimage.binary_fill_holes.html#scipy.ndimage.binary_fill_holes" title="scipy.ndimage.binary_fill_holes"><code class="xref py py-func docutils literal"><span class="pre">binary_fill_holes</span></code></a> function is used to close holes in
objects in a binary image, where the structure defines the
connectivity of the holes. The origin parameter controls the
placement of the structuring element as described in
<a class="reference internal" href="#ndimage-filter-functions"><span class="std std-ref">Filter functions</span></a>. If no structuring element is
provided, an element with connectivity equal to one is generated
using <a class="reference internal" href="../generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure" title="scipy.ndimage.generate_binary_structure"><code class="xref py py-func docutils literal"><span class="pre">generate_binary_structure</span></code></a>.</li>
<li>The <a class="reference internal" href="../generated/scipy.ndimage.binary_hit_or_miss.html#scipy.ndimage.binary_hit_or_miss" title="scipy.ndimage.binary_hit_or_miss"><code class="xref py py-func docutils literal"><span class="pre">binary_hit_or_miss</span></code></a> function implements a binary
hit-or-miss transform of arrays of arbitrary rank with the given
structuring elements. The hit-or-miss transform is calculated by
erosion of the input with the first structure, erosion of the
logical <em>not</em> of the input with the second structure, followed by
the logical <em>and</em> of these two erosions. The origin parameters
control the placement of the structuring elements as described in
<a class="reference internal" href="#ndimage-filter-functions"><span class="std std-ref">Filter functions</span></a>. If <em>origin2</em> equals None it is set
equal to the <em>origin1</em> parameter. If the first structuring element
is not provided, a structuring element with connectivity equal to
one is generated using <a class="reference internal" href="../generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure" title="scipy.ndimage.generate_binary_structure"><code class="xref py py-func docutils literal"><span class="pre">generate_binary_structure</span></code></a>, if
<em>structure2</em> is not provided, it is set equal to the logical <em>not</em>
of <em>structure1</em>.</li>
</ul>
</div>
<div class="section" id="grey-scale-morphology">
<span id="ndimage-grey-morphology"></span><h3>Grey-scale morphology<a class="headerlink" href="#grey-scale-morphology" title="Permalink to this headline">¶</a></h3>
<p>Grey-scale morphology operations are the equivalents of binary
morphology operations that operate on arrays with arbitrary values.
Below we describe the grey-scale equivalents of erosion, dilation,
opening and closing. These operations are implemented in a similar
fashion as the filters described in <a class="reference internal" href="#ndimage-filter-functions"><span class="std std-ref">Filter functions</span></a>,
and we refer to this section for the description of filter kernels and
footprints, and the handling of array borders. The grey-scale
morphology operations optionally take a <em>structure</em> parameter that
gives the values of the structuring element. If this parameter is not
given the structuring element is assumed to be flat with a value equal
to zero. The shape of the structure can optionally be defined by the
<em>footprint</em> parameter.  If this parameter is not given, the structure
is assumed to be rectangular, with sizes equal to the dimensions of
the <em>structure</em> array, or by the <em>size</em> parameter if <em>structure</em> is
not given. The <em>size</em> parameter is only used if both <em>structure</em> and
<em>footprint</em> are not given, in which case the structuring element is
assumed to be rectangular and flat with the dimensions given by
<em>size</em>. The <em>size</em> parameter, if provided, must be a sequence of sizes
or a single number in which case the size of the filter is assumed to
be equal along each axis. The <em>footprint</em> parameter, if provided, must
be an array that defines the shape of the kernel by its non-zero
elements.</p>
<p>Similar to binary erosion and dilation there are operations for
grey-scale erosion and dilation:</p>
<ul class="simple">
<li>The <a class="reference internal" href="../generated/scipy.ndimage.grey_erosion.html#scipy.ndimage.grey_erosion" title="scipy.ndimage.grey_erosion"><code class="xref py py-func docutils literal"><span class="pre">grey_erosion</span></code></a> function calculates a multidimensional
grey- scale erosion.</li>
<li>The <a class="reference internal" href="../generated/scipy.ndimage.grey_dilation.html#scipy.ndimage.grey_dilation" title="scipy.ndimage.grey_dilation"><code class="xref py py-func docutils literal"><span class="pre">grey_dilation</span></code></a> function calculates a multidimensional
grey-scale dilation.</li>
</ul>
<p>Grey-scale opening and closing operations can be defined similar to
their binary counterparts:</p>
<ul class="simple">
<li>The <a class="reference internal" href="../generated/scipy.ndimage.grey_opening.html#scipy.ndimage.grey_opening" title="scipy.ndimage.grey_opening"><code class="xref py py-func docutils literal"><span class="pre">grey_opening</span></code></a> function implements grey-scale opening of
arrays of arbitrary rank. Grey-scale opening is equivalent to a
grey-scale erosion followed by a grey-scale dilation.</li>
<li>The <a class="reference internal" href="../generated/scipy.ndimage.grey_closing.html#scipy.ndimage.grey_closing" title="scipy.ndimage.grey_closing"><code class="xref py py-func docutils literal"><span class="pre">grey_closing</span></code></a> function implements grey-scale closing of
arrays of arbitrary rank. Grey-scale opening is equivalent to a
grey-scale dilation followed by a grey-scale erosion.</li>
<li>The <a class="reference internal" href="../generated/scipy.ndimage.morphological_gradient.html#scipy.ndimage.morphological_gradient" title="scipy.ndimage.morphological_gradient"><code class="xref py py-func docutils literal"><span class="pre">morphological_gradient</span></code></a> function implements a grey-scale
morphological gradient of arrays of arbitrary rank. The grey-scale
morphological gradient is equal to the difference of a grey-scale
dilation and a grey-scale erosion.</li>
<li>The <a class="reference internal" href="../generated/scipy.ndimage.morphological_laplace.html#scipy.ndimage.morphological_laplace" title="scipy.ndimage.morphological_laplace"><code class="xref py py-func docutils literal"><span class="pre">morphological_laplace</span></code></a> function implements a grey-scale
morphological laplace of arrays of arbitrary rank. The grey-scale
morphological laplace is equal to the sum of a grey-scale dilation
and a grey-scale erosion minus twice the input.</li>
<li>The <a class="reference internal" href="../generated/scipy.ndimage.white_tophat.html#scipy.ndimage.white_tophat" title="scipy.ndimage.white_tophat"><code class="xref py py-func docutils literal"><span class="pre">white_tophat</span></code></a> function implements a white top-hat filter
of arrays of arbitrary rank. The white top-hat is equal to the
difference of the input and a grey-scale opening.</li>
<li>The <a class="reference internal" href="../generated/scipy.ndimage.black_tophat.html#scipy.ndimage.black_tophat" title="scipy.ndimage.black_tophat"><code class="xref py py-func docutils literal"><span class="pre">black_tophat</span></code></a> function implements a black top-hat filter
of arrays of arbitrary rank. The black top-hat is equal to the
difference of a grey-scale closing and the input.</li>
</ul>
</div>
</div>
<div class="section" id="distance-transforms">
<span id="ndimage-distance-transforms"></span><h2>Distance transforms<a class="headerlink" href="#distance-transforms" title="Permalink to this headline">¶</a></h2>
<p>Distance transforms are used to calculate the minimum distance from
each element of an object to the background. The following functions
implement distance transforms for three different distance metrics:
Euclidean, City Block, and Chessboard distances.</p>
<ul>
<li><p class="first">The function <a class="reference internal" href="../generated/scipy.ndimage.distance_transform_cdt.html#scipy.ndimage.distance_transform_cdt" title="scipy.ndimage.distance_transform_cdt"><code class="xref py py-func docutils literal"><span class="pre">distance_transform_cdt</span></code></a> uses a chamfer type
algorithm to calculate the distance transform of the input, by
replacing each object element (defined by values larger than zero)
with the shortest distance to the background (all non-object
elements). The structure determines the type of chamfering that is
done. If the structure is equal to ‘cityblock’ a structure is
generated using <a class="reference internal" href="../generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure" title="scipy.ndimage.generate_binary_structure"><code class="xref py py-func docutils literal"><span class="pre">generate_binary_structure</span></code></a> with a squared
distance equal to 1. If the structure is equal to ‘chessboard’, a
structure is generated using <a class="reference internal" href="../generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure" title="scipy.ndimage.generate_binary_structure"><code class="xref py py-func docutils literal"><span class="pre">generate_binary_structure</span></code></a> with
a squared distance equal to the rank of the array. These choices
correspond to the common interpretations of the cityblock and the
chessboard distance metrics in two dimensions.</p>
<p>In addition to the distance transform, the feature transform can be
calculated. In this case the index of the closest background element
is returned along the first axis of the result. The
<em>return_distances</em>, and <em>return_indices</em> flags can be used to
indicate if the distance transform, the feature transform, or both
must be returned.</p>
<p>The <em>distances</em> and <em>indices</em> arguments can be used to give optional
output arrays that must be of the correct size and type (both
<code class="xref c c-type docutils literal"><span class="pre">Int32</span></code>). The basics of the algorithm used to implement this
function is described in <a class="footnote-reference" href="#id12" id="id3">[2]</a>.</p>
</li>
<li><p class="first">The function <a class="reference internal" href="../generated/scipy.ndimage.distance_transform_edt.html#scipy.ndimage.distance_transform_edt" title="scipy.ndimage.distance_transform_edt"><code class="xref py py-func docutils literal"><span class="pre">distance_transform_edt</span></code></a> calculates the exact
euclidean distance transform of the input, by replacing each object
element (defined by values larger than zero) with the shortest
euclidean distance to the background (all non-object elements).</p>
<p>In addition to the distance transform, the feature transform can be
calculated. In this case the index of the closest background element
is returned along the first axis of the result. The
<em>return_distances</em>, and <em>return_indices</em> flags can be used to
indicate if the distance transform, the feature transform, or both
must be returned.</p>
<p>Optionally the sampling along each axis can be given by the
<em>sampling</em> parameter which should be a sequence of length equal to
the input rank, or a single number in which the sampling is assumed
to be equal along all axes.</p>
<p>The <em>distances</em> and <em>indices</em> arguments can be used to give optional
output arrays that must be of the correct size and type
(<code class="xref c c-type docutils literal"><span class="pre">Float64</span></code> and <code class="xref c c-type docutils literal"><span class="pre">Int32</span></code>).The algorithm used to
implement this function is described in <a class="footnote-reference" href="#id13" id="id4">[3]</a>.</p>
</li>
<li><p class="first">The function <a class="reference internal" href="../generated/scipy.ndimage.distance_transform_bf.html#scipy.ndimage.distance_transform_bf" title="scipy.ndimage.distance_transform_bf"><code class="xref py py-func docutils literal"><span class="pre">distance_transform_bf</span></code></a> uses a brute-force
algorithm to calculate the distance transform of the input, by
replacing each object element (defined by values larger than zero)
with the shortest distance to the background (all non-object
elements). The metric must be one of “euclidean”, “cityblock”, or
“chessboard”.</p>
<p>In addition to the distance transform, the feature transform can be
calculated. In this case the index of the closest background element
is returned along the first axis of the result. The
<em>return_distances</em>, and <em>return_indices</em> flags can be used to
indicate if the distance transform, the feature transform, or both
must be returned.</p>
<p>Optionally the sampling along each axis can be given by the
<em>sampling</em> parameter which should be a sequence of length equal to
the input rank, or a single number in which the sampling is assumed
to be equal along all axes. This parameter is only used in the case
of the euclidean distance transform.</p>
<p>The <em>distances</em> and <em>indices</em> arguments can be used to give optional
output arrays that must be of the correct size and type
(<code class="xref c c-type docutils literal"><span class="pre">Float64</span></code> and <code class="xref c c-type docutils literal"><span class="pre">Int32</span></code>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function uses a slow brute-force algorithm, the function
<a class="reference internal" href="../generated/scipy.ndimage.distance_transform_cdt.html#scipy.ndimage.distance_transform_cdt" title="scipy.ndimage.distance_transform_cdt"><code class="xref py py-func docutils literal"><span class="pre">distance_transform_cdt</span></code></a> can be used to more efficiently
calculate cityblock and chessboard distance transforms. The
function <a class="reference internal" href="../generated/scipy.ndimage.distance_transform_edt.html#scipy.ndimage.distance_transform_edt" title="scipy.ndimage.distance_transform_edt"><code class="xref py py-func docutils literal"><span class="pre">distance_transform_edt</span></code></a> can be used to more
efficiently calculate the exact euclidean distance transform.</p>
</div>
</li>
</ul>
</div>
<div class="section" id="segmentation-and-labeling">
<h2>Segmentation and labeling<a class="headerlink" href="#segmentation-and-labeling" title="Permalink to this headline">¶</a></h2>
<p>Segmentation is the process of separating objects of interest from
the background. The most simple approach is probably intensity
thresholding, which is easily done with <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/index.html#module-numpy" title="(in NumPy v1.13)"><code class="xref py py-mod docutils literal"><span class="pre">numpy</span></code></a> functions:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">array([[0, 1, 1, 0, 0, 0],</span>
<span class="go">       [0, 1, 1, 0, 1, 0],</span>
<span class="go">       [0, 0, 0, 1, 1, 1],</span>
<span class="go">       [0, 0, 0, 0, 1, 0]])</span>
</pre></div>
</div>
<p>The result is a binary image, in which the individual objects still
need to be identified and labeled. The function <a class="reference internal" href="../generated/scipy.ndimage.label.html#scipy.ndimage.label" title="scipy.ndimage.label"><code class="xref py py-func docutils literal"><span class="pre">label</span></code></a>
generates an array where each object is assigned a unique number:</p>
<ul>
<li><p class="first">The <a class="reference internal" href="../generated/scipy.ndimage.label.html#scipy.ndimage.label" title="scipy.ndimage.label"><code class="xref py py-func docutils literal"><span class="pre">label</span></code></a> function generates an array where the objects in
the input are labeled with an integer index. It returns a tuple
consisting of the array of object labels and the number of objects
found, unless the <em>output</em> parameter is given, in which case only
the number of objects is returned. The connectivity of the objects
is defined by a structuring element. For instance, in two dimensions
using a four-connected structuring element gives:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="k">import</span> <span class="n">label</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="go">(array([[0, 1, 1, 0, 0, 0],</span>
<span class="go">        [0, 1, 1, 0, 2, 0],</span>
<span class="go">        [0, 0, 0, 2, 2, 2],</span>
<span class="go">        [0, 0, 0, 0, 2, 0]]), 2)</span>
</pre></div>
</div>
<p>These two objects are not connected because there is no way in which
we can place the structuring element such that it overlaps with both
objects. However, an 8-connected structuring element results in only
a single object:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">array([[0, 1, 1, 0, 0, 0],</span>
<span class="go">       [0, 1, 1, 0, 1, 0],</span>
<span class="go">       [0, 0, 0, 1, 1, 1],</span>
<span class="go">       [0, 0, 0, 0, 1, 0]])</span>
</pre></div>
</div>
<p>If no structuring element is provided, one is generated by calling
<a class="reference internal" href="../generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure" title="scipy.ndimage.generate_binary_structure"><code class="xref py py-func docutils literal"><span class="pre">generate_binary_structure</span></code></a> (see
<a class="reference internal" href="#ndimage-binary-morphology"><span class="std std-ref">Binary morphology</span></a>) using a connectivity of one (which
in 2D is the 4-connected structure of the first example). The input
can be of any type, any value not equal to zero is taken to be part
of an object. This is useful if you need to ‘re-label’ an array of
object indices, for instance after removing unwanted objects. Just
apply the label function again to the index array. For instance:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">label</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span>
<span class="go">array([1, 0, 2, 0, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">l</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span>
<span class="go">array([1, 0, 0, 0, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label</span><span class="p">(</span><span class="n">l</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">array([1, 0, 0, 0, 2])</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The structuring element used by <a class="reference internal" href="../generated/scipy.ndimage.label.html#scipy.ndimage.label" title="scipy.ndimage.label"><code class="xref py py-func docutils literal"><span class="pre">label</span></code></a> is assumed to be
symmetric.</p>
</div>
</li>
</ul>
<p>There is a large number of other approaches for segmentation, for
instance from an estimation of the borders of the objects that can be
obtained for instance by derivative filters. One such an approach is
watershed segmentation. The function <a class="reference internal" href="../generated/scipy.ndimage.watershed_ift.html#scipy.ndimage.watershed_ift" title="scipy.ndimage.watershed_ift"><code class="xref py py-func docutils literal"><span class="pre">watershed_ift</span></code></a> generates
an array where each object is assigned a unique label, from an array
that localizes the object borders, generated for instance by a
gradient magnitude filter. It uses an array containing initial markers
for the objects:</p>
<ul>
<li><p class="first">The <a class="reference internal" href="../generated/scipy.ndimage.watershed_ift.html#scipy.ndimage.watershed_ift" title="scipy.ndimage.watershed_ift"><code class="xref py py-func docutils literal"><span class="pre">watershed_ift</span></code></a> function applies a watershed from markers
algorithm, using an Iterative Forest Transform, as described in
<a class="footnote-reference" href="#id14" id="id5">[4]</a>.</p>
</li>
<li><p class="first">The inputs of this function are the array to which the transform is
applied, and an array of markers that designate the objects by a
unique label, where any non-zero value is a marker. For instance:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">markers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="k">import</span> <span class="n">watershed_ift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">watershed_ift</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">markers</span><span class="p">)</span>
<span class="go">array([[1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 2, 2, 2, 1, 1],</span>
<span class="go">       [1, 2, 2, 2, 2, 2, 1],</span>
<span class="go">       [1, 2, 2, 2, 2, 2, 1],</span>
<span class="go">       [1, 2, 2, 2, 2, 2, 1],</span>
<span class="go">       [1, 1, 2, 2, 2, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1]], dtype=int8)</span>
</pre></div>
</div>
<p>Here two markers were used to designate an object (<em>marker</em> = 2) and
the background (<em>marker</em> = 1). The order in which these are
processed is arbitrary: moving the marker for the background to the
lower right corner of the array yields a different result:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">markers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">watershed_ift</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">markers</span><span class="p">)</span>
<span class="go">array([[1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 2, 2, 2, 1, 1],</span>
<span class="go">       [1, 1, 2, 2, 2, 1, 1],</span>
<span class="go">       [1, 1, 2, 2, 2, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1]], dtype=int8)</span>
</pre></div>
</div>
<p>The result is that the object (<em>marker</em> = 2) is smaller because the
second marker was processed earlier. This may not be the desired
effect if the first marker was supposed to designate a background
object. Therefore <a class="reference internal" href="../generated/scipy.ndimage.watershed_ift.html#scipy.ndimage.watershed_ift" title="scipy.ndimage.watershed_ift"><code class="xref py py-func docutils literal"><span class="pre">watershed_ift</span></code></a> treats markers with a
negative value explicitly as background markers and processes them
after the normal markers. For instance, replacing the first marker
by a negative marker gives a result similar to the first example:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">markers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">watershed_ift</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">markers</span><span class="p">)</span>
<span class="go">array([[-1, -1, -1, -1, -1, -1, -1],</span>
<span class="go">       [-1, -1,  2,  2,  2, -1, -1],</span>
<span class="go">       [-1,  2,  2,  2,  2,  2, -1],</span>
<span class="go">       [-1,  2,  2,  2,  2,  2, -1],</span>
<span class="go">       [-1,  2,  2,  2,  2,  2, -1],</span>
<span class="go">       [-1, -1,  2,  2,  2, -1, -1],</span>
<span class="go">       [-1, -1, -1, -1, -1, -1, -1]], dtype=int8)</span>
</pre></div>
</div>
<p>The connectivity of the objects is defined by a structuring
element. If no structuring element is provided, one is generated by
calling <a class="reference internal" href="../generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure" title="scipy.ndimage.generate_binary_structure"><code class="xref py py-func docutils literal"><span class="pre">generate_binary_structure</span></code></a> (see
<a class="reference internal" href="#ndimage-binary-morphology"><span class="std std-ref">Binary morphology</span></a>) using a connectivity of one (which
in 2D is a 4-connected structure.) For example, using an 8-connected
structure with the last example yields a different object:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">watershed_ift</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">markers</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">structure</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="go">array([[-1, -1, -1, -1, -1, -1, -1],</span>
<span class="go">       [-1,  2,  2,  2,  2,  2, -1],</span>
<span class="go">       [-1,  2,  2,  2,  2,  2, -1],</span>
<span class="go">       [-1,  2,  2,  2,  2,  2, -1],</span>
<span class="go">       [-1,  2,  2,  2,  2,  2, -1],</span>
<span class="go">       [-1,  2,  2,  2,  2,  2, -1],</span>
<span class="go">       [-1, -1, -1, -1, -1, -1, -1]], dtype=int8)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The implementation of <a class="reference internal" href="../generated/scipy.ndimage.watershed_ift.html#scipy.ndimage.watershed_ift" title="scipy.ndimage.watershed_ift"><code class="xref py py-func docutils literal"><span class="pre">watershed_ift</span></code></a> limits the data types
of the input to <code class="xref c c-type docutils literal"><span class="pre">UInt8</span></code> and <code class="xref c c-type docutils literal"><span class="pre">UInt16</span></code>.</p>
</div>
</li>
</ul>
</div>
<div class="section" id="object-measurements">
<span id="ndimage-object-measurements"></span><h2>Object measurements<a class="headerlink" href="#object-measurements" title="Permalink to this headline">¶</a></h2>
<p>Given an array of labeled objects, the properties of the individual
objects can be measured. The <a class="reference internal" href="../generated/scipy.ndimage.find_objects.html#scipy.ndimage.find_objects" title="scipy.ndimage.find_objects"><code class="xref py py-func docutils literal"><span class="pre">find_objects</span></code></a> function can be used
to generate a list of slices that for each object, give the
smallest sub-array that fully contains the object:</p>
<ul>
<li><p class="first">The <a class="reference internal" href="../generated/scipy.ndimage.find_objects.html#scipy.ndimage.find_objects" title="scipy.ndimage.find_objects"><code class="xref py py-func docutils literal"><span class="pre">find_objects</span></code></a> function finds all objects in a labeled
array and returns a list of slices that correspond to the smallest
regions in the array that contains the object.</p>
<p>For instance:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="k">import</span> <span class="n">find_objects</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">find_objects</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
<span class="go">array([[1, 1],</span>
<span class="go">       [1, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
<span class="go">array([[0, 1, 0],</span>
<span class="go">       [1, 1, 1],</span>
<span class="go">       [0, 1, 0]])</span>
</pre></div>
</div>
<p>The function <a class="reference internal" href="../generated/scipy.ndimage.find_objects.html#scipy.ndimage.find_objects" title="scipy.ndimage.find_objects"><code class="xref py py-func docutils literal"><span class="pre">find_objects</span></code></a> returns slices for all objects,
unless the <em>max_label</em> parameter is larger then zero, in which case
only the first <em>max_label</em> objects are returned. If an index is
missing in the <em>label</em> array, <code class="docutils literal"><span class="pre">None</span></code> is return instead of a
slice. For example:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="k">import</span> <span class="n">find_objects</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_objects</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">max_label</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[(slice(0, 1, None),), None, (slice(2, 3, None),)]</span>
</pre></div>
</div>
</li>
</ul>
<p>The list of slices generated by <a class="reference internal" href="../generated/scipy.ndimage.find_objects.html#scipy.ndimage.find_objects" title="scipy.ndimage.find_objects"><code class="xref py py-func docutils literal"><span class="pre">find_objects</span></code></a> is useful to find
the position and dimensions of the objects in the array, but can also
be used to perform measurements on the individual objects. Say we want
to find the sum of the intensities of an object in image:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">slices</span> <span class="o">=</span> <span class="n">find_objects</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
</pre></div>
</div>
<p>Then we can calculate the sum of the elements in the second object:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">slices</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="n">image</span><span class="p">[</span><span class="n">slices</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="go">80</span>
</pre></div>
</div>
<p>That is however not particularly efficient, and may also be more
complicated for other types of measurements. Therefore a few
measurements functions are defined that accept the array of object
labels and the index of the object to be measured. For instance
calculating the sum of the intensities can be done by:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="k">import</span> <span class="nb">sum</span> <span class="k">as</span> <span class="n">ndi_sum</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndi_sum</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">80</span>
</pre></div>
</div>
<p>For large arrays and small objects it is more efficient to call the
measurement functions after slicing the array:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ndi_sum</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="n">slices</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">labels</span><span class="p">[</span><span class="n">slices</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">80</span>
</pre></div>
</div>
<p>Alternatively, we can do the measurements for a number of labels with
a single function call, returning a list of results. For instance, to
measure the sum of the values of the background and the second object
in our example we give a list of labels:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ndi_sum</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">array([178.0, 80.0])</span>
</pre></div>
</div>
<p>The measurement functions described below all support the <em>index</em>
parameter to indicate which object(s) should be measured. The default
value of <em>index</em> is None. This indicates that all elements where the
label is larger than zero should be treated as a single object and
measured. Thus, in this case the <em>labels</em> array is treated as a mask
defined by the elements that are larger than zero. If <em>index</em> is a
number or a sequence of numbers it gives the labels of the objects
that are measured. If <em>index</em> is a sequence, a list of the results is
returned. Functions that return more than one result, return their
result as a tuple if <em>index</em> is a single number, or as a tuple of
lists, if <em>index</em> is a sequence.</p>
<ul class="simple">
<li>The <a class="reference internal" href="../generated/scipy.ndimage.sum.html#scipy.ndimage.sum" title="scipy.ndimage.sum"><code class="xref py py-func docutils literal"><span class="pre">sum</span></code></a> function calculates the sum of the elements of the
object with label(s) given by <em>index</em>, using the <em>labels</em> array for
the object labels. If <em>index</em> is <code class="docutils literal"><span class="pre">None</span></code>, all elements with a
non-zero label value are treated as a single object. If <em>label</em> is
<code class="docutils literal"><span class="pre">None</span></code>, all elements of <em>input</em> are used in the calculation.</li>
<li>The <a class="reference internal" href="../generated/scipy.ndimage.mean.html#scipy.ndimage.mean" title="scipy.ndimage.mean"><code class="xref py py-func docutils literal"><span class="pre">mean</span></code></a> function calculates the mean of the elements of the
object with label(s) given by <em>index</em>, using the <em>labels</em> array for
the object labels. If <em>index</em> is <code class="docutils literal"><span class="pre">None</span></code>, all elements with a
non-zero label value are treated as a single object. If <em>label</em> is
<code class="docutils literal"><span class="pre">None</span></code>, all elements of <em>input</em> are used in the calculation.</li>
<li>The <a class="reference internal" href="../generated/scipy.ndimage.variance.html#scipy.ndimage.variance" title="scipy.ndimage.variance"><code class="xref py py-func docutils literal"><span class="pre">variance</span></code></a> function calculates the variance of the
elements of the object with label(s) given by <em>index</em>, using the
<em>labels</em> array for the object labels. If <em>index</em> is <code class="docutils literal"><span class="pre">None</span></code>, all
elements with a non-zero label value are treated as a single
object. If <em>label</em> is <code class="docutils literal"><span class="pre">None</span></code>, all elements of <em>input</em> are used in
the calculation.</li>
<li>The <a class="reference internal" href="../generated/scipy.ndimage.standard_deviation.html#scipy.ndimage.standard_deviation" title="scipy.ndimage.standard_deviation"><code class="xref py py-func docutils literal"><span class="pre">standard_deviation</span></code></a> function calculates the standard
deviation of the elements of the object with label(s) given by
<em>index</em>, using the <em>labels</em> array for the object labels. If <em>index</em>
is <code class="docutils literal"><span class="pre">None</span></code>, all elements with a non-zero label value are treated as
a single object. If <em>label</em> is <code class="docutils literal"><span class="pre">None</span></code>, all elements of <em>input</em> are
used in the calculation.</li>
<li>The <a class="reference internal" href="../generated/scipy.ndimage.minimum.html#scipy.ndimage.minimum" title="scipy.ndimage.minimum"><code class="xref py py-func docutils literal"><span class="pre">minimum</span></code></a> function calculates the minimum of the elements
of the object with label(s) given by <em>index</em>, using the <em>labels</em>
array for the object labels. If <em>index</em> is <code class="docutils literal"><span class="pre">None</span></code>, all elements
with a non-zero label value are treated as a single object. If
<em>label</em> is <code class="docutils literal"><span class="pre">None</span></code>, all elements of <em>input</em> are used in the
calculation.</li>
<li>The <a class="reference internal" href="../generated/scipy.ndimage.maximum.html#scipy.ndimage.maximum" title="scipy.ndimage.maximum"><code class="xref py py-func docutils literal"><span class="pre">maximum</span></code></a> function calculates the maximum of the elements
of the object with label(s) given by <em>index</em>, using the <em>labels</em>
array for the object labels. If <em>index</em> is <code class="docutils literal"><span class="pre">None</span></code>, all elements
with a non-zero label value are treated as a single object. If
<em>label</em> is <code class="docutils literal"><span class="pre">None</span></code>, all elements of <em>input</em> are used in the
calculation.</li>
<li>The <a class="reference internal" href="../generated/scipy.ndimage.minimum_position.html#scipy.ndimage.minimum_position" title="scipy.ndimage.minimum_position"><code class="xref py py-func docutils literal"><span class="pre">minimum_position</span></code></a> function calculates the position of the
minimum of the elements of the object with label(s) given by
<em>index</em>, using the <em>labels</em> array for the object labels. If <em>index</em>
is <code class="docutils literal"><span class="pre">None</span></code>, all elements with a non-zero label value are treated as
a single object. If <em>label</em> is <code class="docutils literal"><span class="pre">None</span></code>, all elements of <em>input</em> are
used in the calculation.</li>
<li>The <a class="reference internal" href="../generated/scipy.ndimage.maximum_position.html#scipy.ndimage.maximum_position" title="scipy.ndimage.maximum_position"><code class="xref py py-func docutils literal"><span class="pre">maximum_position</span></code></a> function calculates the position of the
maximum of the elements of the object with label(s) given by
<em>index</em>, using the <em>labels</em> array for the object labels. If <em>index</em>
is <code class="docutils literal"><span class="pre">None</span></code>, all elements with a non-zero label value are treated as
a single object. If <em>label</em> is <code class="docutils literal"><span class="pre">None</span></code>, all elements of <em>input</em> are
used in the calculation.</li>
<li>The <a class="reference internal" href="../generated/scipy.ndimage.extrema.html#scipy.ndimage.extrema" title="scipy.ndimage.extrema"><code class="xref py py-func docutils literal"><span class="pre">extrema</span></code></a> function calculates the minimum, the maximum,
and their positions, of the elements of the object with label(s)
given by <em>index</em>, using the <em>labels</em> array for the object labels. If
<em>index</em> is <code class="docutils literal"><span class="pre">None</span></code>, all elements with a non-zero label value are
treated as a single object. If <em>label</em> is <code class="docutils literal"><span class="pre">None</span></code>, all elements of
<em>input</em> are used in the calculation. The result is a tuple giving
the minimum, the maximum, the position of the minimum and the
position of the maximum. The result is the same as a tuple formed by
the results of the functions <em>minimum</em>, <em>maximum</em>,
<em>minimum_position</em>, and <em>maximum_position</em> that are described above.</li>
<li>The <a class="reference internal" href="../generated/scipy.ndimage.center_of_mass.html#scipy.ndimage.center_of_mass" title="scipy.ndimage.center_of_mass"><code class="xref py py-func docutils literal"><span class="pre">center_of_mass</span></code></a> function calculates the center of mass of
the of the object with label(s) given by <em>index</em>, using the <em>labels</em>
array for the object labels. If <em>index</em> is <code class="docutils literal"><span class="pre">None</span></code>, all elements
with a non-zero label value are treated as a single object. If
<em>label</em> is <code class="docutils literal"><span class="pre">None</span></code>, all elements of <em>input</em> are used in the
calculation.</li>
<li>The <a class="reference internal" href="../generated/scipy.ndimage.histogram.html#scipy.ndimage.histogram" title="scipy.ndimage.histogram"><code class="xref py py-func docutils literal"><span class="pre">histogram</span></code></a> function calculates a histogram of the of the
object with label(s) given by <em>index</em>, using the <em>labels</em> array for
the object labels. If <em>index</em> is <code class="docutils literal"><span class="pre">None</span></code>, all elements with a
non-zero label value are treated as a single object. If <em>label</em> is
<code class="docutils literal"><span class="pre">None</span></code>, all elements of <em>input</em> are used in the calculation.
Histograms are defined by their minimum (<em>min</em>), maximum (<em>max</em>) and
the number of bins (<em>bins</em>). They are returned as one-dimensional
arrays of type <code class="xref c c-type docutils literal"><span class="pre">Int32</span></code>.</li>
</ul>
</div>
<div class="section" id="extending-scipy-ndimage-in-c">
<span id="ndimage-ccallbacks"></span><h2>Extending <a class="reference internal" href="../ndimage.html#module-scipy.ndimage" title="scipy.ndimage"><code class="xref py py-mod docutils literal"><span class="pre">scipy.ndimage</span></code></a> in C<a class="headerlink" href="#extending-scipy-ndimage-in-c" title="Permalink to this headline">¶</a></h2>
<p>A few functions in <a class="reference internal" href="../ndimage.html#module-scipy.ndimage" title="scipy.ndimage"><code class="xref py py-mod docutils literal"><span class="pre">scipy.ndimage</span></code></a> take a callback argument. This
can be either a python function or a <a class="reference internal" href="../generated/scipy.LowLevelCallable.html#scipy.LowLevelCallable" title="scipy.LowLevelCallable"><code class="xref py py-obj docutils literal"><span class="pre">scipy.LowLevelCallable</span></code></a> containing a
pointer to a C function. Using a C function will generally be more
efficient since it avoids the overhead of calling a python function on
many elements of an array. To use a C function you must write a C
extension that contains the callback function and a Python function
that returns a <a class="reference internal" href="../generated/scipy.LowLevelCallable.html#scipy.LowLevelCallable" title="scipy.LowLevelCallable"><code class="xref py py-obj docutils literal"><span class="pre">scipy.LowLevelCallable</span></code></a> containing a pointer to the
callback.</p>
<p>An example of a function that supports callbacks is
<a class="reference internal" href="../generated/scipy.ndimage.geometric_transform.html#scipy.ndimage.geometric_transform" title="scipy.ndimage.geometric_transform"><code class="xref py py-func docutils literal"><span class="pre">geometric_transform</span></code></a>, which accepts a callback function that
defines a mapping from all output coordinates to corresponding
coordinates in the input array. Consider the following python example
which uses <a class="reference internal" href="../generated/scipy.ndimage.geometric_transform.html#scipy.ndimage.geometric_transform" title="scipy.ndimage.geometric_transform"><code class="xref py py-func docutils literal"><span class="pre">geometric_transform</span></code></a> to implement a shift function.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">ndimage</span>

<span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">output_coordinates</span><span class="p">,</span> <span class="n">shift</span><span class="p">):</span>
    <span class="n">input_coordinates</span> <span class="o">=</span> <span class="n">output_coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">shift</span><span class="p">,</span> <span class="n">output_coordinates</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">shift</span>
    <span class="k">return</span> <span class="n">input_coordinates</span>

<span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="n">shift</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ndimage</span><span class="o">.</span><span class="n">geometric_transform</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="n">extra_arguments</span><span class="o">=</span><span class="p">(</span><span class="n">shift</span><span class="p">,)))</span>
</pre></div>
</div>
<p>We can also implement the callback function with the following C code.</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span>/* example.c */

#include &lt;Python.h&gt;
#include &lt;numpy/npy_common.h&gt;

static int
_transform(npy_intp *output_coordinates, double *input_coordinates,
           int output_rank, int input_rank, void *user_data)
{
    npy_intp i;
    double shift = *(double *)user_data;

    for (i = 0; i &lt; input_rank; i++) {
        input_coordinates[i] = output_coordinates[i] - shift;
    }
    return 1;
}

static char *transform_signature = &quot;int (npy_intp *, double *, int, int, void *)&quot;;

static PyObject *
py_get_transform(PyObject *obj, PyObject *args)
{
    if (!PyArg_ParseTuple(args, &quot;&quot;)) return NULL;
    return PyCapsule_New(_transform, transform_signature, NULL);
}

static PyMethodDef ExampleMethods[] = {
    {&quot;get_transform&quot;, (PyCFunction)py_get_transform, METH_VARARGS, &quot;&quot;},
    {NULL, NULL, 0, NULL}
};

/* Initialize the module */
#if PY_VERSION_HEX &gt;= 0x03000000
static struct PyModuleDef example = {
    PyModuleDef_HEAD_INIT,
    &quot;example&quot;,
    NULL,
    -1,
    ExampleMethods,
    NULL,
    NULL,
    NULL,
    NULL
};

PyMODINIT_FUNC
PyInit_example(void)
{
    return PyModule_Create(&amp;example);
}
#else
PyMODINIT_FUNC
initexample(void)
{
    Py_InitModule(&quot;example&quot;, ExampleMethods);
}
#endif
</pre></div>
</div>
<p>More information on writing Python extension modules can be found
<a class="reference external" href="https://docs.python.org/2/extending/extending.html">here</a>. If the C code is in the file <code class="docutils literal"><span class="pre">example.c</span></code>, then it can be
compiled with the following <code class="docutils literal"><span class="pre">setup.py</span></code>,</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">distutils.core</span> <span class="k">import</span> <span class="n">setup</span><span class="p">,</span> <span class="n">Extension</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="n">shift</span> <span class="o">=</span> <span class="n">Extension</span><span class="p">(</span><span class="s1">&#39;example&#39;</span><span class="p">,</span>
                  <span class="p">[</span><span class="s1">&#39;example.c&#39;</span><span class="p">],</span>
                  <span class="n">include_dirs</span><span class="o">=</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">get_include</span><span class="p">()]</span>
<span class="p">)</span>

<span class="n">setup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;example&#39;</span><span class="p">,</span>
      <span class="n">ext_modules</span><span class="o">=</span><span class="p">[</span><span class="n">shift</span><span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
<p>and now running the script</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">ctypes</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">ndimage</span><span class="p">,</span> <span class="n">LowLevelCallable</span>

<span class="kn">from</span> <span class="nn">example</span> <span class="k">import</span> <span class="n">get_transform</span>

<span class="n">shift</span> <span class="o">=</span> <span class="mf">0.5</span>

<span class="n">user_data</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span>
<span class="n">ptr</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="n">user_data</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">)</span>
<span class="n">callback</span> <span class="o">=</span> <span class="n">LowLevelCallable</span><span class="p">(</span><span class="n">transform</span><span class="p">(),</span> <span class="n">ptr</span><span class="p">)</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ndimage</span><span class="o">.</span><span class="n">geometric_transform</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">callback</span><span class="p">))</span>
</pre></div>
</div>
<p>produces the same result as the original python script.</p>
<p>In the C version <code class="docutils literal"><span class="pre">_transform</span></code> is the callback function and the
parameters <code class="docutils literal"><span class="pre">output_coordinates</span></code> and <code class="docutils literal"><span class="pre">input_coordinates</span></code> play the
same role as they do in the python version while <code class="docutils literal"><span class="pre">output_rank</span></code> and
<code class="docutils literal"><span class="pre">input_rank</span></code> provide the equivalents of <code class="docutils literal"><span class="pre">len(output_coordinates)</span></code>
and <code class="docutils literal"><span class="pre">len(input_coordinates)</span></code>. The variable <code class="docutils literal"><span class="pre">shift</span></code> is passed
through <code class="docutils literal"><span class="pre">user_data</span></code> instead of
<code class="docutils literal"><span class="pre">extra_arguments</span></code>. Finally, the C callback function returns an integer
status which is one upon success and zero otherwise.</p>
<p>The function <code class="docutils literal"><span class="pre">py_transform</span></code> wraps the callback function in a
<a class="reference external" href="https://docs.python.org/dev/c-api/capsule.html#c.PyCapsule" title="(in Python v3.7)"><code class="xref c c-type docutils literal"><span class="pre">PyCapsule</span></code></a>. The main steps are:</p>
<ul>
<li><p class="first">Initialize a <a class="reference external" href="https://docs.python.org/dev/c-api/capsule.html#c.PyCapsule" title="(in Python v3.7)"><code class="xref c c-type docutils literal"><span class="pre">PyCapsule</span></code></a>. The first argument is a pointer to
the callback function.</p>
</li>
<li><p class="first">The second argument is the function signature which must match exactly
the one expected by <code class="xref py py-mod docutils literal"><span class="pre">ndimage</span></code>.</p>
</li>
<li><p class="first">Above, we used  <a class="reference internal" href="../generated/scipy.LowLevelCallable.html#scipy.LowLevelCallable" title="scipy.LowLevelCallable"><code class="xref py py-obj docutils literal"><span class="pre">scipy.LowLevelCallable</span></code></a> to specify <code class="docutils literal"><span class="pre">user_data</span></code>
that we generated with <a class="reference external" href="https://docs.python.org/dev/library/ctypes.html#module-ctypes" title="(in Python v3.7)"><code class="xref py py-obj docutils literal"><span class="pre">ctypes</span></code></a>.</p>
<p>A different approach would be to supply the data in the capsule context,
that can be set by <a href="#id7"><span class="problematic" id="id8">:cfunc:`PyCapsule_SetContext`</span></a> and omit specifying
<code class="docutils literal"><span class="pre">user_data</span></code> in <a class="reference internal" href="../generated/scipy.LowLevelCallable.html#scipy.LowLevelCallable" title="scipy.LowLevelCallable"><code class="xref py py-obj docutils literal"><span class="pre">scipy.LowLevelCallable</span></code></a>. However, in this approach we would
need to deal with allocation/freeing of the data — freeing the data
after the capsule is destroyed can be done by specifying a non-NULL
callback function in the third argument of <a href="#id9"><span class="problematic" id="id10">:cfunc:`PyCapsule_New`</span></a>.</p>
</li>
</ul>
<p>C callback functions for <code class="xref py py-mod docutils literal"><span class="pre">ndimage</span></code> all follow this scheme. The
next section lists the <code class="xref py py-mod docutils literal"><span class="pre">ndimage</span></code> functions that accept a C
callback function and gives the prototype of the function.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p>The functions that support low-level callback arguments are:</p>
<p class="last"><a class="reference internal" href="../generated/scipy.ndimage.generic_filter.html#scipy.ndimage.generic_filter" title="scipy.ndimage.generic_filter"><code class="xref py py-obj docutils literal"><span class="pre">generic_filter</span></code></a>, <a class="reference internal" href="../generated/scipy.ndimage.generic_filter1d.html#scipy.ndimage.generic_filter1d" title="scipy.ndimage.generic_filter1d"><code class="xref py py-obj docutils literal"><span class="pre">generic_filter1d</span></code></a>, <a class="reference internal" href="../generated/scipy.ndimage.geometric_transform.html#scipy.ndimage.geometric_transform" title="scipy.ndimage.geometric_transform"><code class="xref py py-obj docutils literal"><span class="pre">geometric_transform</span></code></a></p>
</div>
<p>Below, we show alternative ways to write the code, using <a class="reference external" href="http://cython.org/">Cython</a>,
<a class="reference external" href="https://docs.python.org/3/library/ctypes.html">ctypes</a>, or <a class="reference external" href="https://cffi.readthedocs.io/">cffi</a> instead of writing wrapper code in C.</p>
<p class="rubric">Numba</p>
<p><a class="reference external" href="http://numba.pydata.org/">Numba</a> provides a way to write low-level functions easily in Python.
We can write the above using Numba as:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># example.py</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">ctypes</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">ndimage</span><span class="p">,</span> <span class="n">LowLevelCallable</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="k">import</span> <span class="n">cfunc</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">carray</span>

<span class="nd">@cfunc</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">intc</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">CPointer</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">intp</span><span class="p">),</span>
                  <span class="n">types</span><span class="o">.</span><span class="n">CPointer</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">double</span><span class="p">),</span>
                  <span class="n">types</span><span class="o">.</span><span class="n">intc</span><span class="p">,</span>
                  <span class="n">types</span><span class="o">.</span><span class="n">intc</span><span class="p">,</span>
                  <span class="n">types</span><span class="o">.</span><span class="n">voidptr</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">output_coordinates_ptr</span><span class="p">,</span> <span class="n">input_coordinates_ptr</span><span class="p">,</span>
              <span class="n">output_rank</span><span class="p">,</span> <span class="n">input_rank</span><span class="p">,</span> <span class="n">user_data</span><span class="p">):</span>
    <span class="n">input_coordinates</span> <span class="o">=</span> <span class="n">carray</span><span class="p">(</span><span class="n">input_coordinates_ptr</span><span class="p">,</span> <span class="p">(</span><span class="n">input_rank</span><span class="p">,))</span>
    <span class="n">output_coordinates</span> <span class="o">=</span> <span class="n">carray</span><span class="p">(</span><span class="n">output_coordinates_ptr</span><span class="p">,</span> <span class="p">(</span><span class="n">output_rank</span><span class="p">,))</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="n">carray</span><span class="p">(</span><span class="n">user_data</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="n">types</span><span class="o">.</span><span class="n">double</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">input_rank</span><span class="p">):</span>
        <span class="n">input_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">shift</span>

    <span class="k">return</span> <span class="mi">1</span>

<span class="n">shift</span> <span class="o">=</span> <span class="mf">0.5</span>

<span class="c1"># Then call the function</span>
<span class="n">user_data</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span>
<span class="n">ptr</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="n">user_data</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">)</span>
<span class="n">callback</span> <span class="o">=</span> <span class="n">LowLevelCallable</span><span class="p">(</span><span class="n">transform</span><span class="o">.</span><span class="n">ctypes</span><span class="p">,</span> <span class="n">ptr</span><span class="p">)</span>

<span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ndimage</span><span class="o">.</span><span class="n">geometric_transform</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">callback</span><span class="p">))</span>
</pre></div>
</div>
<p class="rubric">Cython</p>
<p>Functionally the same code as above can be written in Cython with
somewhat less boilerplate as follows.</p>
<div class="code cython highlight-default"><div class="highlight"><pre><span></span><span class="c1"># example.pyx</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="n">cimport</span> <span class="n">npy_intp</span> <span class="k">as</span> <span class="n">intp</span>

<span class="n">cdef</span> <span class="n">api</span> <span class="nb">int</span> <span class="n">transform</span><span class="p">(</span><span class="n">intp</span> <span class="o">*</span><span class="n">output_coordinates</span><span class="p">,</span> <span class="n">double</span> <span class="o">*</span><span class="n">input_coordinates</span><span class="p">,</span>
                       <span class="nb">int</span> <span class="n">output_rank</span><span class="p">,</span> <span class="nb">int</span> <span class="n">input_rank</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">):</span>
    <span class="n">cdef</span> <span class="n">intp</span> <span class="n">i</span>
    <span class="n">cdef</span> <span class="n">double</span> <span class="n">shift</span> <span class="o">=</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">double</span> <span class="o">*&gt;</span><span class="n">user_data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">input_rank</span><span class="p">):</span>
        <span class="n">input_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">shift</span>
    <span class="k">return</span> <span class="mi">1</span>
</pre></div>
</div>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># script.py</span>

<span class="kn">import</span> <span class="nn">ctypes</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">ndimage</span><span class="p">,</span> <span class="n">LowLevelCallable</span>

<span class="kn">import</span> <span class="nn">example</span>

<span class="n">shift</span> <span class="o">=</span> <span class="mf">0.5</span>

<span class="n">user_data</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span>
<span class="n">ptr</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="n">user_data</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">)</span>
<span class="n">callback</span> <span class="o">=</span> <span class="n">LowLevelCallable</span><span class="o">.</span><span class="n">from_cython</span><span class="p">(</span><span class="n">example</span><span class="p">,</span> <span class="s2">&quot;transform&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">)</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ndimage</span><span class="o">.</span><span class="n">geometric_transform</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">callback</span><span class="p">))</span>
</pre></div>
</div>
<p class="rubric">cffi</p>
<p>With <a class="reference external" href="https://cffi.readthedocs.io/">cffi</a>, you can interface with a C function residing in a shared
library (DLL). First, we need to write the shared library, which we do
in C — this example is for Linux/OSX:</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span>
  <span class="n">example</span><span class="o">.</span><span class="n">c</span>
  <span class="n">Needs</span> <span class="n">to</span> <span class="n">be</span> <span class="n">compiled</span> <span class="k">with</span> <span class="s2">&quot;gcc -std=c99 -shared -fPIC -o example.so example.c&quot;</span>
  <span class="ow">or</span> <span class="n">similar</span>
 <span class="o">*/</span>

<span class="c1">#include &lt;stdint.h&gt;</span>

<span class="nb">int</span>
<span class="n">_transform</span><span class="p">(</span><span class="n">intptr_t</span> <span class="o">*</span><span class="n">output_coordinates</span><span class="p">,</span> <span class="n">double</span> <span class="o">*</span><span class="n">input_coordinates</span><span class="p">,</span>
           <span class="nb">int</span> <span class="n">output_rank</span><span class="p">,</span> <span class="nb">int</span> <span class="n">input_rank</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nb">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">double</span> <span class="n">shift</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">double</span> <span class="o">*</span><span class="p">)</span><span class="n">user_data</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">input_rank</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">input_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">shift</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The Python code calling the library is:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">ndimage</span><span class="p">,</span> <span class="n">LowLevelCallable</span>
<span class="kn">import</span> <span class="nn">cffi</span>

<span class="c1"># Construct the FFI object, and copypaste the function declaration</span>
<span class="n">ffi</span> <span class="o">=</span> <span class="n">cffi</span><span class="o">.</span><span class="n">FFI</span><span class="p">()</span>
<span class="n">ffi</span><span class="o">.</span><span class="n">cdef</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">int _transform(intptr_t *output_coordinates, double *input_coordinates,</span>
<span class="s2">               int output_rank, int input_rank, void *user_data);</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>

<span class="c1"># Open library</span>
<span class="n">lib</span> <span class="o">=</span> <span class="n">ffi</span><span class="o">.</span><span class="n">dlopen</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="s2">&quot;example.so&quot;</span><span class="p">))</span>

<span class="c1"># Do the function call</span>
<span class="n">user_data</span> <span class="o">=</span> <span class="n">ffi</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;double *&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">callback</span> <span class="o">=</span> <span class="n">LowLevelCallable</span><span class="p">(</span><span class="n">lib</span><span class="o">.</span><span class="n">_transform</span><span class="p">,</span> <span class="n">user_data</span><span class="p">)</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ndimage</span><span class="o">.</span><span class="n">geometric_transform</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">callback</span><span class="p">))</span>
</pre></div>
</div>
<p>You can find more information in the <a class="reference external" href="https://cffi.readthedocs.io/">cffi</a> documentation.</p>
<p class="rubric">ctypes</p>
<p>With <em>ctypes</em>, the C code and the compilation of the so/DLL is as for
cffi above.  The Python code is different:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># script.py</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">ctypes</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">ndimage</span><span class="p">,</span> <span class="n">LowLevelCallable</span>

<span class="n">lib</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">CDLL</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="s1">&#39;example.so&#39;</span><span class="p">))</span>

<span class="n">shift</span> <span class="o">=</span> <span class="mf">0.5</span>

<span class="n">user_data</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span>
<span class="n">ptr</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="n">user_data</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">)</span>

<span class="c1"># Ctypes has no built-in intptr type, so override the signature</span>
<span class="c1"># instead of trying to get it via ctypes</span>
<span class="n">callback</span> <span class="o">=</span> <span class="n">LowLevelCallable</span><span class="p">(</span><span class="n">lib</span><span class="o">.</span><span class="n">_transform</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span>
    <span class="s2">&quot;int _transform(intptr_t *, double *, int, int, void *)&quot;</span><span class="p">)</span>

<span class="c1"># Perform the call</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ndimage</span><span class="o">.</span><span class="n">geometric_transform</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">callback</span><span class="p">))</span>
</pre></div>
</div>
<p>You can find more information in the <a class="reference external" href="https://docs.python.org/3/library/ctypes.html">ctypes</a> documentation.</p>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>M. Unser, “Splines: A Perfect Fit for Signal and Image
Processing,” IEEE Signal Processing Magazine, vol. 16, no. 6, pp.
22-38, November 1999.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>G. Borgefors, “Distance transformations in arbitrary
dimensions.”, Computer Vision, Graphics, and Image Processing,
27:321-345, 1984.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[3]</a></td><td>C. R. Maurer, Jr., R. Qi, and V. Raghavan, “A linear time
algorithm for computing exact euclidean distance transforms of
binary images in arbitrary dimensions. IEEE Trans. PAMI 25,
265-270, 2003.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[4]</a></td><td>P. Felkel, R. Wegenkittl, and M. Bruckschwaiger,
“Implementation and Complexity of the Watershed-from-Markers Algorithm
Computed as a Minimal Cost Forest.”, Eurographics 2001, pp. C:26-35.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2008-2016, The Scipy community.
      </li>
      <li>
      Last updated on Sep 20, 2017.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.3.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>