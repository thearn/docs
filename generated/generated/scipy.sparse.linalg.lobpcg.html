<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>scipy.sparse.linalg.lobpcg &mdash; SciPy v1.1.0.dev0+04759f9 Reference Guide</title>
    
    <link rel="stylesheet" type="text/css" href="../../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../../_static/css/spc-extend.css">
    <link rel="stylesheet" href="../../_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.1.0.dev0+04759f9',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/scipy-mathjax/MathJax.js?config=scipy-mathjax"></script>
    <script type="text/javascript" src="../../_static/js/copybutton.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" >
    <link rel="search" title="Search" href="../../search.html" >
    <link rel="top" title="SciPy v1.1.0.dev0+04759f9 Reference Guide" href="../../index.html" >
    <link rel="up" title="scipy.sparse.linalg" href="../scipy.sparse.linalg.html" >
    <link rel="next" title="scipy.sparse.linalg.svds" href="scipy.sparse.linalg.svds.html" >
    <link rel="prev" title="scipy.sparse.linalg.eigsh" href="scipy.sparse.linalg.eigsh.html" > 
  </head>
  <body>

  <div class="container">
    <div class="header">
    </div>
  </div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
	
        <li class="active"><a href="../../index.html">SciPy v1.1.0.dev0+04759f9 Reference Guide</a></li>
	
          <li class="active"><a href="../../sparse.html" >Sparse matrices (<code class="docutils literal"><span class="pre">scipy.sparse</span></code>)</a></li>
          <li class="active"><a href="../scipy.sparse.linalg.html" accesskey="U">scipy.sparse.linalg</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="../../py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
      <li class="active">
        <a href="scipy.sparse.linalg.svds.html" title="scipy.sparse.linalg.svds"
           accesskey="N">next</a>
      </li>
      <li class="active">
        <a href="scipy.sparse.linalg.eigsh.html" title="scipy.sparse.linalg.eigsh"
           accesskey="P">previous</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/scipyshiny_small.png" alt="Logo">
            </a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="scipy.sparse.linalg.eigsh.html"
                        title="previous chapter">scipy.sparse.linalg.eigsh</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="scipy.sparse.linalg.svds.html"
                        title="next chapter">scipy.sparse.linalg.svds</a></p>


        </div>
      </div>
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="scipy-sparse-linalg-lobpcg">
<h1>scipy.sparse.linalg.lobpcg<a class="headerlink" href="#scipy-sparse-linalg-lobpcg" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="scipy.sparse.linalg.lobpcg">
<code class="descclassname">scipy.sparse.linalg.</code><code class="descname">lobpcg</code><span class="sig-paren">(</span><em>A</em>, <em>X</em>, <em>B=None</em>, <em>M=None</em>, <em>Y=None</em>, <em>tol=None</em>, <em>maxiter=20</em>, <em>largest=True</em>, <em>verbosityLevel=0</em>, <em>retLambdaHistory=False</em>, <em>retResidualNormsHistory=False</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scipy/scipy/blob/04759f9/scipy/sparse/linalg/eigen/lobpcg/lobpcg.py#L109-L568"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scipy.sparse.linalg.lobpcg" title="Permalink to this definition">¶</a></dt>
<dd><p>Locally Optimal Block Preconditioned Conjugate Gradient Method (LOBPCG)</p>
<p>LOBPCG is a preconditioned eigensolver for large symmetric positive
definite (SPD) generalized eigenproblems.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : {sparse matrix, dense matrix, LinearOperator}</p>
<blockquote>
<div><p>The symmetric linear operator of the problem, usually a
sparse matrix.  Often called the “stiffness matrix”.</p>
</div></blockquote>
<p><strong>X</strong> : array_like</p>
<blockquote>
<div><p>Initial approximation to the k eigenvectors. If A has
shape=(n,n) then X should have shape shape=(n,k).</p>
</div></blockquote>
<p><strong>B</strong> : {dense matrix, sparse matrix, LinearOperator}, optional</p>
<blockquote>
<div><p>the right hand side operator in a generalized eigenproblem.
by default, B = Identity
often called the “mass matrix”</p>
</div></blockquote>
<p><strong>M</strong> : {dense matrix, sparse matrix, LinearOperator}, optional</p>
<blockquote>
<div><p>preconditioner to A; by default M = Identity
M should approximate the inverse of A</p>
</div></blockquote>
<p><strong>Y</strong> : array_like, optional</p>
<blockquote>
<div><p>n-by-sizeY matrix of constraints, sizeY &lt; n
The iterations will be performed in the B-orthogonal complement
of the column-space of Y. Y must be full rank.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>w</strong> : array</p>
<blockquote>
<div><p>Array of k eigenvalues</p>
</div></blockquote>
<p><strong>v</strong> : array</p>
<blockquote>
<div><p>An array of k eigenvectors.  V has the same shape as X.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><p class="first"><strong>tol</strong> : scalar, optional</p>
<blockquote>
<div><p>Solver tolerance (stopping criterion)
by default: tol=n*sqrt(eps)</p>
</div></blockquote>
<p><strong>maxiter</strong> : integer, optional</p>
<blockquote>
<div><p>maximum number of iterations
by default: maxiter=min(n,20)</p>
</div></blockquote>
<p><strong>largest</strong> : bool, optional</p>
<blockquote>
<div><p>when True, solve for the largest eigenvalues, otherwise the smallest</p>
</div></blockquote>
<p><strong>verbosityLevel</strong> : integer, optional</p>
<blockquote>
<div><p>controls solver output.  default: verbosityLevel = 0.</p>
</div></blockquote>
<p><strong>retLambdaHistory</strong> : boolean, optional</p>
<blockquote>
<div><p>whether to return eigenvalue history</p>
</div></blockquote>
<p><strong>retResidualNormsHistory</strong> : boolean, optional</p>
<blockquote class="last">
<div><p>whether to return history of residual norms</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>If both retLambdaHistory and retResidualNormsHistory are True,
the return tuple has the following format
(lambda, V, lambda history, residual norms history).</p>
<p>In the following <code class="docutils literal"><span class="pre">n</span></code> denotes the matrix size and <code class="docutils literal"><span class="pre">m</span></code> the number
of required eigenvalues (smallest or largest).</p>
<p>The LOBPCG code internally solves eigenproblems of the size 3``m`` on every
iteration by calling the “standard” dense eigensolver, so if <code class="docutils literal"><span class="pre">m</span></code> is not
small enough compared to <code class="docutils literal"><span class="pre">n</span></code>, it does not make sense to call the LOBPCG
code, but rather one should use the “standard” eigensolver,
e.g. numpy or scipy function in this case.
If one calls the LOBPCG algorithm for 5``m``&gt;``n``,
it will most likely break internally, so the code tries to call the standard
function instead.</p>
<p>It is not that n should be large for the LOBPCG to work, but rather the
ratio <code class="docutils literal"><span class="pre">n</span></code>/<code class="docutils literal"><span class="pre">m</span></code> should be large. It you call the LOBPCG code with <code class="docutils literal"><span class="pre">m``=1</span>
<span class="pre">and</span> <span class="pre">``n``=10,</span> <span class="pre">it</span> <span class="pre">should</span> <span class="pre">work,</span> <span class="pre">though</span> <span class="pre">``n</span></code> is small. The method is intended
for extremely large <code class="docutils literal"><span class="pre">n</span></code>/<code class="docutils literal"><span class="pre">m</span></code>, see e.g., reference [28] in
<a class="reference external" href="http://arxiv.org/abs/0705.2626">http://arxiv.org/abs/0705.2626</a></p>
<p>The convergence speed depends basically on two factors:</p>
<ol class="arabic simple">
<li>How well relatively separated the seeking eigenvalues are
from the rest of the eigenvalues.
One can try to vary <code class="docutils literal"><span class="pre">m</span></code> to make this better.</li>
<li>How well conditioned the problem is. This can be changed by using proper
preconditioning. For example, a rod vibration test problem (under tests
directory) is ill-conditioned for large <code class="docutils literal"><span class="pre">n</span></code>, so convergence will be
slow, unless efficient preconditioning is used.
For this specific problem, a good simple preconditioner function would
be a linear solve for A, which is easy to code since A is tridiagonal.</li>
</ol>
<p><em>Acknowledgements</em></p>
<p>lobpcg.py code was written by Robert Cimrman.
Many thanks belong to Andrew Knyazev, the author of the algorithm,
for lots of advice and support.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r30" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[R30]</a></td><td>A. V. Knyazev (2001),
Toward the Optimal Preconditioned Eigensolver: Locally Optimal
Block Preconditioned Conjugate Gradient Method.
SIAM Journal on Scientific Computing 23, no. 2,
pp. 517-541. <a class="reference external" href="http://dx.doi.org/10.1137/S1064827500366124">http://dx.doi.org/10.1137/S1064827500366124</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r31" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[R31]</a></td><td>A. V. Knyazev, I. Lashuk, M. E. Argentati, and E. Ovchinnikov (2007),
Block Locally Optimal Preconditioned Eigenvalue Xolvers (BLOPEX)
in hypre and PETSc.  <a class="reference external" href="http://arxiv.org/abs/0705.2626">http://arxiv.org/abs/0705.2626</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r32" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[R32]</a></td><td>A. V. Knyazev’s C and MATLAB implementations:
<a class="reference external" href="https://bitbucket.org/joseroman/blopex">https://bitbucket.org/joseroman/blopex</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Solve A x = lambda B x with constraints and preconditioning.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="k">import</span> <span class="n">spdiags</span><span class="p">,</span> <span class="n">issparse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="k">import</span> <span class="n">lobpcg</span><span class="p">,</span> <span class="n">LinearOperator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">spdiags</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="go">array([[   1.,    0.,    0., ...,    0.,    0.,    0.],</span>
<span class="go">       [   0.,    2.,    0., ...,    0.,    0.,    0.],</span>
<span class="go">       [   0.,    0.,    3., ...,    0.,    0.,    0.],</span>
<span class="go">       ...,</span>
<span class="go">       [   0.,    0.,    0., ...,   98.,    0.,    0.],</span>
<span class="go">       [   0.,    0.,    0., ...,    0.,   99.,    0.],</span>
<span class="go">       [   0.,    0.,    0., ...,    0.,    0.,  100.]])</span>
</pre></div>
</div>
<p>Constraints.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Initial guess for eigenvectors, should have linearly independent
columns. Column dimension = number of requested eigenvalues.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Preconditioner – inverse of A (as an abstract linear operator).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">invA</span> <span class="o">=</span> <span class="n">spdiags</span><span class="p">([</span><span class="mf">1.</span><span class="o">/</span><span class="n">vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">precond</span><span class="p">(</span> <span class="n">x</span> <span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">invA</span>  <span class="o">*</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">LinearOperator</span><span class="p">(</span><span class="n">matvec</span><span class="o">=</span><span class="n">precond</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal"><span class="pre">invA</span></code> could of course have been used directly as a preconditioner.
Let us then solve the problem:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eigs</span><span class="p">,</span> <span class="n">vecs</span> <span class="o">=</span> <span class="n">lobpcg</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">largest</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eigs</span>
<span class="go">array([ 4.,  5.,  6.])</span>
</pre></div>
</div>
<p>Note that the vectors passed in Y are the eigenvectors of the 3 smallest
eigenvalues. The results returned are orthogonal to those.</p>
</dd></dl>

</div>


          </div>
        </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2008-2016, The Scipy community.
      </li>
      <li>
      Last updated on Sep 20, 2017.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.3.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>